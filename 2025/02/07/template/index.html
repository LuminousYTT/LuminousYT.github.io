

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="单击此处插入标题      By 流.云.天.   尽人事，听天命。  一、数据结构1.树状数组 12345678910111213141516&gt;int lowbit(int x)&gt;&#123;return x &amp; -x;&gt;&#125;&gt;int query(int x) &#x2F;&#x2F; 向前查 前缀和 查询从1-x之间的和&gt;&#123;int t &#x3D; 0;wh">
<meta property="og:type" content="article">
<meta property="og:title" content="template">
<meta property="og:url" content="http://example.com/2025/02/07/template/index.html">
<meta property="og:site_name" content="LuminousYT">
<meta property="og:description" content="单击此处插入标题      By 流.云.天.   尽人事，听天命。  一、数据结构1.树状数组 12345678910111213141516&gt;int lowbit(int x)&gt;&#123;return x &amp; -x;&gt;&#125;&gt;int query(int x) &#x2F;&#x2F; 向前查 前缀和 查询从1-x之间的和&gt;&#123;int t &#x3D; 0;wh">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\LYT\Documents\cpp\File_Markdown\P6492.png">
<meta property="og:image" content="c:\Users\LYT\Documents\cpp\File_Markdown\scanlines.jpg">
<meta property="og:image" content="c:\Users\LYT\Documents\cpp\File_Markdown\Splay_rotate.png">
<meta property="og:image" content="c:\Users\LYT\Documents\cpp\File_Markdown\P3387.jpg">
<meta property="og:image" content="c:\Users\LYT\Documents\cpp\File_Markdown\P2889.jpg">
<meta property="article:published_time" content="2025-02-07T12:38:27.000Z">
<meta property="article:modified_time" content="2025-02-07T13:09:37.071Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="XCPC">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:\Users\LYT\Documents\cpp\File_Markdown\P6492.png">
  
  
  
  <title>template - LuminousYT</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>LuminousYT</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="template"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-07 20:38" pubdate>
          2025年2月7日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          164 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">template</h1>
            
            
              <div class="markdown-body">
                
                <center><font size="6">    <strong> 单击此处插入标题 </strong>  </font></center>

<center> By 流.云.天. </center>

<p align="right"><i>尽人事，听天命。</i></p>

<h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><h3 id="1-树状数组"><a href="#1-树状数组" class="headerlink" title="1.树状数组"></a>1.树状数组</h3><blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">return</span> x &amp; -x;<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 向前查 前缀和 查询从1-x之间的和</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x)<br>	t += s[x], x -= <span class="hljs-built_in">lowbit</span>(x);<br><span class="hljs-keyword">return</span> t;<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span> <span class="hljs-comment">// 向后修 改变一个根节点的值</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">while</span> (x &lt;= n)<br>	s[x] += k, x += <span class="hljs-built_in">lowbit</span>(x);<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="2-并查集"><a href="#2-并查集" class="headerlink" title="2.并查集"></a>2.并查集</h3><blockquote>
<p>我们定义<code>fa[x]</code>是存节点x的父节点 ，<code>fa[x]</code>初始化每个节点的父节点是他自己</p>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-comment">// 带路径压缩的查找</span><br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (fa[x] == x)<br>	<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&gt;&#125;<br><br>&gt;<span class="hljs-comment">// 合并 把x集合的根指向y集合的根</span><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionset</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>fa[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y);<br>&gt;&#125;<br><br>&gt;<span class="hljs-comment">// 按秩合并（启发式合并） 把小集合的根指向大集合的根</span><br>&gt;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">siz</span><span class="hljs-params">(N, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 记录初始化子树的大小为1</span><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionset</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>x = <span class="hljs-built_in">find</span>(x), y = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span> (x == y)<br>	<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (siz[x] &gt; siz[y])<br>	<span class="hljs-built_in">swap</span>(x, y);<br>fa[x] = y;<br>siz[y] += siz[x];<br>&gt;&#125;<br><br></code></pre></td></tr></table></figure></blockquote>
<h3 id="3-单调队列（滑动窗口）"><a href="#3-单调队列（滑动窗口）" class="headerlink" title="3.单调队列（滑动窗口）"></a>3.单调队列（滑动窗口）</h3><blockquote>
<p>查询区间内最大&#x2F;最小的数</p>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Num</span><br>&#123;<br>	<span class="hljs-type">int</span> index, x; <span class="hljs-comment">// 需要记录单调队列内每个数的入队时间(index)和大小(x)</span><br>&#125;;<br><br><span class="hljs-type">int</span> a[MAXN]; <span class="hljs-comment">// 原数组</span><br>Num q[MAXN]; <span class="hljs-comment">// 单调队列</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n, m;		 <span class="hljs-comment">// n表示序列长度，m表示滑动窗口长度</span><br>	<span class="hljs-type">int</span> front, back; <span class="hljs-comment">// front,back分别表示队头、队尾位置</span><br>	<span class="hljs-comment">// 输入</span><br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>	<span class="hljs-comment">// 问题解决</span><br>	front = <span class="hljs-number">1</span>;<br>	back = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化队头队尾位置，队头&gt;队尾表示队空</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		<span class="hljs-comment">// 先输出数a[i]前的最小值</span><br>		<span class="hljs-keyword">if</span> (front &gt; back) <span class="hljs-comment">// q空，即a[i]前没有元素</span><br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>		<span class="hljs-keyword">else</span><br>		&#123;								<span class="hljs-comment">// 否则判断队头是否需要出队并输出范围内的队头</span><br>			<span class="hljs-keyword">if</span> (q[front].index + m &lt; i) <span class="hljs-comment">// 队头已经超出滑动窗口范围</span><br>				front++;				<span class="hljs-comment">// 弹出队头</span><br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, q[front].x); <span class="hljs-comment">// 此时队一定非空（想想为什么）</span><br>		&#125;<br>		<span class="hljs-keyword">while</span> (front &lt;= back &amp;&amp; q[back].x &gt;= a[i])<br>			<span class="hljs-comment">// 当队列非空时，不断弹出队尾比当前元素大的元素</span><br>			back--;<br>		back++;<br>		q[back].x = a[i];<br>		q[back].index = i; <span class="hljs-comment">// 将当前元素入队</span><br>		<span class="hljs-comment">// 注意：当前元素无论如何都会入队（想想为什么）</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="4-单调栈"><a href="#4-单调栈" class="headerlink" title="4.单调栈"></a>4.单调栈</h3><blockquote>
<p>查询第i个数左边&#x2F;右边第一个比这个数小&#x2F;大的下标</p>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>&#123;<br>	cin &gt;&gt; a[i];<br>	<span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; a[st.<span class="hljs-built_in">top</span>()] &lt; a[i])<span class="hljs-comment">//此处可以更改比较关系</span><br>	&#123;<br>		ans[st.<span class="hljs-built_in">top</span>()] = i;<br>		st.<span class="hljs-built_in">pop</span>();<br>	&#125;<br>	st.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>	cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="5-ST表"><a href="#5-ST表" class="headerlink" title="5.ST表"></a>5.ST表</h3><blockquote>
<p>求区间最值问题(RMQ) 运用了倍增的思想</p>
</blockquote>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[N], lg2[N];<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">20</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n, m;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)<br>		lg2[i] = lg2[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		cin &gt;&gt; f[i][<span class="hljs-number">0</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= lg2[n]; ++j)<span class="hljs-comment">//初始化</span><br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>)) &lt;= n; ++i)<br>		&#123;<br>			f[i][j] = <span class="hljs-built_in">max</span>(f[i][j - <span class="hljs-number">1</span>], f[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">while</span> (m--)<br>	&#123;<br>		<span class="hljs-type">int</span> l, r, k;<br>		cin &gt;&gt; l &gt;&gt; r;<br>		k = lg2[r - l + <span class="hljs-number">1</span>];<br>		cout &lt;&lt; <span class="hljs-built_in">max</span>(f[l][k], f[r - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]) &lt;&lt; endl;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="6-线段树"><a href="#6-线段树" class="headerlink" title="6.线段树"></a>6.线段树</h3><blockquote>
<p>区间乘x 区间加x(重点在于懒标记的使用)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> lc p &lt;&lt; 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rc p &lt;&lt; 1 | 1 <span class="hljs-comment">// rc=lc+1 lc=p*2</span></span><br><span class="hljs-type">int</span> n,	q, mod, a[N]; <span class="hljs-comment">// w所要维护的数组</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	ll l, r, sum, add, mul;<br>&#125; tr[N * <span class="hljs-number">4</span>]; <span class="hljs-comment">// 节点数组</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(node &amp;t, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>	t.sum = (t.sum * m + (t.r - t.l + <span class="hljs-number">1</span>) * a) % mod;<br>	t.mul = t.mul * m % mod;<br>	t.add = (t.add * m + a) % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(ll p)</span> <span class="hljs-comment">// 向上更新</span></span><br><span class="hljs-function"></span>&#123;<br>	tr[p].sum = tr[lc].sum + tr[rc].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(ll p)</span> <span class="hljs-comment">// 向下更新</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">calc</span>(tr[lc], tr[p].add, tr[p].mul);<br>	<span class="hljs-built_in">calc</span>(tr[rc], tr[p].add, tr[p].mul);<br>	tr[p].add = <span class="hljs-number">0</span>;<br>	tr[p].mul = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll p, ll x, ll y)</span> <span class="hljs-comment">// 区间查询 查询[x,y]之间所有元素的和</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (x &lt;= tr[p].l &amp;&amp; tr[p].r &lt;= y) <span class="hljs-comment">// 覆盖则返回</span><br>		<span class="hljs-keyword">return</span> tr[p].sum;<br>	ll m = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 不覆盖则裂开</span><br>	<span class="hljs-built_in">pushdown</span>(p);<br>	ll sum = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span> (x &lt;= m)<br>		sum += <span class="hljs-built_in">query</span>(lc, x, y);<br>	<span class="hljs-keyword">if</span> (y &gt; m)<br>		sum += <span class="hljs-built_in">query</span>(rc, x, y);<br>	<span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll p, ll l, ll r)</span> <span class="hljs-comment">// p根节点的编号</span></span><br><span class="hljs-function"></span>&#123;<br>	tr[p] = &#123;l, r, a[l], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>	<span class="hljs-keyword">if</span> (l == r)<br>		<span class="hljs-keyword">return</span>;		   <span class="hljs-comment">// 是叶子节点</span><br>	ll m = l + r &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 不是叶子节点</span><br>	<span class="hljs-built_in">build</span>(lc, l, m);<br>	<span class="hljs-built_in">build</span>(rc, m + <span class="hljs-number">1</span>, r);<br>	<span class="hljs-comment">// tr[p].sum=tr[lc].sum+tr[rc].sum;</span><br>	<span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll p, ll x, ll y, ll a, ll m)</span> <span class="hljs-comment">// 区间修改 对区间[x,y]之间所有的数加上k</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (x &gt; tr[p].r || y &lt; tr[p].l)<br>		<span class="hljs-keyword">return</span>;<br>	<span class="hljs-keyword">if</span> (x &lt;= tr[p].l &amp;&amp; tr[p].r &lt;= y) <span class="hljs-comment">// 覆盖则修改</span><br>	&#123;<br>		<span class="hljs-built_in">calc</span>(tr[p], a, m);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">pushdown</span>(p);<br>	<span class="hljs-built_in">update</span>(lc, x, y, a, m);<br>	<span class="hljs-built_in">update</span>(rc, x, y, a, m);<br>	<span class="hljs-built_in">pushup</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>用线段树 在线算出区间最大&#x2F;最小值<br>当 $c$ 为 $Q$ 的时候，表示这是一条询问操作，它询问 ID 从 $a$ 到 $b$（包括 $a$ , $b$） 的学生当中，成绩最高的是多少；<br>当 $c$ 为 $U$ 的时候，表示这是一条更新操作，如果当前 $a$ 学生的成绩低于 $b$，则把 ID 为 $a$ 的学生的成绩更改为 b，否则不改动。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">int</span> a[N], tr[<span class="hljs-number">4</span> * N];<br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>tr[p] = <span class="hljs-built_in">max</span>(tr[rc], tr[lc]);<br>&gt;&#125;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (l == r)<br>&#123;<br>	tr[p] = a[l];<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(lc, l, mid);<br><span class="hljs-built_in">build</span>(rc, mid + <span class="hljs-number">1</span>, r);<br><span class="hljs-built_in">pushup</span>(p);<br>&gt;&#125;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (l == r)<br>&#123;<br>	<span class="hljs-keyword">if</span> (tr[p] &lt; b)<br>		tr[p] = b;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (a &lt;= mid)<br>	<span class="hljs-built_in">update</span>(lc, l, mid, a, b);<br><span class="hljs-keyword">else</span><br>	<span class="hljs-built_in">update</span>(rc, mid + <span class="hljs-number">1</span>, r, a, b);<br><span class="hljs-built_in">pushup</span>(p);<br>&gt;&#125;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b)<br>	<span class="hljs-keyword">return</span> tr[p];<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, ans = -inf;<br><span class="hljs-keyword">if</span> (a &lt;= mid)<br>	ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">query</span>(lc, l, mid, a, b));<br><span class="hljs-keyword">if</span> (b &gt; mid)<br>	ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">query</span>(rc, mid + <span class="hljs-number">1</span>, r, a, b));<br><span class="hljs-keyword">return</span> ans;<br>&gt;&#125;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>	cin &gt;&gt; a[i];<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br>	<span class="hljs-type">char</span> op;<br>	cin &gt;&gt; op;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;U&#x27;</span>)<br>	&#123;<br>		<span class="hljs-type">int</span> a, b;<br>		cin &gt;&gt; a &gt;&gt; b;<br>		<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a, b);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-type">int</span> a, b;<br>		cin &gt;&gt; a &gt;&gt; b;<br>		cout &lt;&lt; <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, a, b) &lt;&lt; endl;<br>	&#125;<br>&#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>权值线段树 维护区间内数的出现次数，区间范围是数据的值域 要进行离散化 </p>
<p>离散化的步骤：</p>
<ol>
<li>备份数组b[i]&#x3D;a[i]</li>
<li>对数组进行升序排序</li>
<li>对b数组去重</li>
<li>在b中二分查找a[i]的下标</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, ans = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>&#123;<br>    cin &gt;&gt; a[i];<br>  	b[i] = a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(b + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span> + n);<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">unique</span>(b + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span> + n) - b - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>线段树区间合并(可作为模板&#x2F;大致思路)  洛谷P6492</p>
<p>题目描述如下：<br>给定一个长度为 $n$ 的字符序列 a，初始时序列中全部都是字符 L。有 $q$ 次修改操作，每次给定一个索引 $x$。如果 <code>a[x]</code> 是 L，则将其修改为 R；如果 a[x] 是 R，则将其修改为 L。一个只包含字符 L 和 R 的字符串 s 被称为满足要求，如果其中不存在连续的 L 和 R。每次修改后，需要输出当前序列 a 中最长的满足要求的连续子串的长度。</p>
<p><img src="C:\Users\LYT\Documents\cpp\File_Markdown\P6492.png" srcset="/img/loading.gif" lazyload alt="P6492"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&gt;&#123;<br>ll l, r, ans, s, h, L, R;<br><span class="hljs-comment">// L:线段树中第 i 个节点所维护的区间的左端点</span><br><span class="hljs-comment">// R:线段树中第 i 个节点所维护的区间的右端点</span><br><span class="hljs-comment">// s:线段树中第 i 个节点所维护的区间的最左端开始最长的符合条件的区间长度（前缀）</span><br><span class="hljs-comment">// h:线段树中第 i 个节点所维护的区间的最右端开始最长的符合条件的区间长度（后缀）</span><br><span class="hljs-comment">// ans:区间最大值</span><br><br>&gt;&#125; tr[N * <span class="hljs-number">4</span>]; <span class="hljs-comment">// 节点数组</span><br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(ll p)</span> <span class="hljs-comment">// 向上更新</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (tr[lc].R ^ tr[rc].L)					<span class="hljs-comment">// 如果左区间的右端点和右区间的左端点不同</span><br>	tr[p].ans = <span class="hljs-built_in">max</span>(&#123;tr[lc].h + tr[rc].s, tr[lc].ans, tr[rc].ans&#125;); <span class="hljs-comment">// 两端合并 左区间最大值 右区间最大值</span><br><span class="hljs-keyword">else</span><br>	tr[p].ans = <span class="hljs-built_in">max</span>(tr[lc].ans, tr[rc].ans);<br>tr[p].L = tr[lc].L;<br>tr[p].R = tr[rc].R;<span class="hljs-comment">//维护L和R</span><br><br><span class="hljs-keyword">if</span> (tr[lc].s == tr[lc].r - tr[lc].l + <span class="hljs-number">1</span> &amp;&amp; tr[lc].R ^ tr[rc].L)<br>	tr[p].s = tr[lc].s + tr[rc].s; <span class="hljs-comment">// 左区间的S包含整个区间并且左区间的右端点与右区间的左端点不同,则两个区间的S合并成大区间的S</span><br><span class="hljs-keyword">else</span><br>	tr[p].s = tr[lc].s; <span class="hljs-comment">// 否则就继承左区间的S</span><br><br><span class="hljs-keyword">if</span> (tr[rc].h == tr[rc].r - tr[rc].l + <span class="hljs-number">1</span> &amp;&amp; tr[lc].R ^ tr[rc].L)<br>	tr[p].h = tr[lc].h + tr[rc].h; <span class="hljs-comment">// 右区间的H包含整个区间并且左区间的右端点与右区间的左端点不同,则两个区间的H合并成大区间的H</span><br><span class="hljs-keyword">else</span><br>	tr[p].h = tr[rc].h; <span class="hljs-comment">// 否则就继承右区间的H</span><br>&gt;&#125;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll p, ll l, ll r)</span> <span class="hljs-comment">// p根节点的编号</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>tr[p] = &#123;l, r, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">if</span> (l == r)<br>	<span class="hljs-keyword">return</span>; <span class="hljs-comment">// 是叶子节点</span><br><br>ll m = l + r &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 不是叶子节点</span><br><span class="hljs-built_in">build</span>(lc, l, m);<br><span class="hljs-built_in">build</span>(rc, m + <span class="hljs-number">1</span>, r);<br><span class="hljs-comment">// tr[p].sum=tr[lc].sum+tr[rc].sum;</span><br><span class="hljs-built_in">pushup</span>(p);<br>&gt;&#125;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll p, ll x, ll y)</span> <span class="hljs-comment">// 单点更改某个节点的值 进行取反</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (x &gt; tr[p].r || y &lt; tr[p].l)<br>	<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (x &lt;= tr[p].l &amp;&amp; tr[p].r &lt;= y) <span class="hljs-comment">// 覆盖则修改</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (tr[p].l == tr[p].r)<br>	&#123;<br>		tr[p].L = !tr[p].L;<br>		tr[p].R = !tr[p].R;<br>	&#125;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//	pushdown(p);</span><br><span class="hljs-built_in">update</span>(lc, x, y);<br><span class="hljs-built_in">update</span>(rc, x, y);<br><span class="hljs-built_in">pushup</span>(p);<br>&gt;&#125;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-type">int</span> n, q;<br>cin &gt;&gt; n &gt;&gt; q;<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><span class="hljs-keyword">while</span> (q--)<br>&#123;<br>	<span class="hljs-type">int</span> x;<br>	cin &gt;&gt; x;<br>	<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, x, x);<br>	cout &lt;&lt; tr[<span class="hljs-number">1</span>].ans &lt;&lt; endl;<br>&#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure>


<p>洛谷P4513 小白逛公园（询问最大子区间和）</p>
<p>题目描述</p>
<p>在小新家附近有一条“公园路”，路的一边从南到北依次排着 $n$ 个公园，小白早就看花了眼，自己也不清楚该去哪些公园玩了。</p>
<p>一开始，小白就根据公园的风景给每个公园打了分。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 $a$ 个和第 $b$ 个公园之间（包括 $a, b$ 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。</p>
<p>在询问的时候，也要做一次类似于合并区间的一次寻找最优值，不能直接返回 <code>max(tree[lc].ans,tree[rc].ans)</code>，因为可能询问的区间不完全包含左儿子或右儿子的区间（若完全包含，则不用合并）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&gt;&#123;<br><span class="hljs-type">int</span> l, r;<br><span class="hljs-type">int</span> s, h; <span class="hljs-comment">// s 区间从左端点开始最大的子区间和(前缀)</span><br><span class="hljs-type">int</span> ans, sum;<br><br>&gt;&#125; tr[N &lt;&lt; <span class="hljs-number">2</span>];<br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(ll p)</span> <span class="hljs-comment">// 向上更新</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>tr[p].sum = tr[lc].sum + tr[rc].sum;<br>tr[p].s = <span class="hljs-built_in">max</span>(tr[lc].s, tr[lc].sum + tr[rc].s);<br>tr[p].h = <span class="hljs-built_in">max</span>(tr[rc].h, tr[rc].sum + tr[lc].h);<br>tr[p].ans = <span class="hljs-built_in">max</span>(&#123;tr[lc].ans, tr[rc].ans, tr[lc].h + tr[rc].s&#125;);<br>&gt;&#125;<br><br>&gt;<span class="hljs-function">node <span class="hljs-title">query</span><span class="hljs-params">(ll p, ll x, ll y)</span> </span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (x &lt;= tr[p].l &amp;&amp; tr[p].r &lt;= y) <span class="hljs-comment">// 覆盖则返回</span><br>	<span class="hljs-keyword">return</span> tr[p];<br>ll m = tr[p].l + tr[p].r &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 不覆盖则裂开</span><br><span class="hljs-keyword">if</span> (y &lt;= m)<span class="hljs-comment">//如果访问的区间全在左儿子里，直接return</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(lc, x, y);<br><span class="hljs-keyword">else</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (x &gt; m)<span class="hljs-comment">//如果访问的区间全在右儿子里，也直接return</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rc, x, y);<br>	<span class="hljs-keyword">else</span><br>	&#123;<span class="hljs-comment">//否则就左右儿子都访问，然后合并区间</span><br>		node t, a = <span class="hljs-built_in">query</span>(lc, x, y), b = <span class="hljs-built_in">query</span>(rc, x, y);<br>		t.s = <span class="hljs-built_in">max</span>(a.s, a.sum + b.s);<br>		t.h = <span class="hljs-built_in">max</span>(b.h, b.sum + a.h);<br>		t.ans = <span class="hljs-built_in">max</span>(&#123;a.ans, b.ans, a.h + b.s&#125;);<br>		<span class="hljs-keyword">return</span> t;<span class="hljs-comment">//返回合并后的区间</span><br>	&#125;<br>&#125;<br>&gt;&#125;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll p, ll l, ll r)</span> <span class="hljs-comment">// p根节点的编号</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>tr[p].l = l, tr[p].r = r;<br><span class="hljs-keyword">if</span> (l == r)<br>&#123;<br>	tr[p] = &#123;l, r, a[l], a[l], a[l], a[l]&#125;;<br>	<span class="hljs-keyword">return</span>; <span class="hljs-comment">// 是叶子节点</span><br>&#125;<br><br>ll m = l + r &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 不是叶子节点</span><br><span class="hljs-built_in">build</span>(lc, l, m);<br><span class="hljs-built_in">build</span>(rc, m + <span class="hljs-number">1</span>, r);<br><span class="hljs-built_in">pushup</span>(p);<br>&gt;&#125;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ll p, ll x, ll y, ll a)</span> </span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (x &gt; tr[p].r || y &lt; tr[p].l)<br>	<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (x &lt;= tr[p].l &amp;&amp; tr[p].r &lt;= y) <span class="hljs-comment">// 覆盖则修改</span><br>&#123;<br>	tr[p].sum = tr[p].ans = tr[p].h = tr[p].s = a;<br>	<span class="hljs-keyword">return</span>;<br>   &#125;<br><span class="hljs-built_in">update</span>(lc, x, y, a);<br><span class="hljs-built_in">update</span>(rc, x, y, a);<br><span class="hljs-built_in">pushup</span>(p);<br>&gt;&#125;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>	cin &gt;&gt; a[i];<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br>	<span class="hljs-type">int</span> op;<br>	cin &gt;&gt; op;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)<br>	&#123;<br>		<span class="hljs-type">int</span> a, b;<br>		cin &gt;&gt; a &gt;&gt; b;<br>		<span class="hljs-keyword">if</span> (a &gt; b)<br>			<span class="hljs-built_in">swap</span>(a, b);<br>		cout &lt;&lt; <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, a, b).ans &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-type">int</span> p, s;<br>		cin &gt;&gt; p &gt;&gt; s;<br>		<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, p, p, s);<br>	&#125;<br>&#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<blockquote>
<p>线段树带区修维护区间gcd</p>
<p>根据更相减损术 我们有<br>$$<br>\gcd(a,b)&#x3D;\gcd(a,a-b)&#x3D;\gcd(a-b,b)<br>$$<br>对这个式子进行扩展<br>$$<br>\gcd(a,b,c)&#x3D;\gcd(a,b-a,c-b)<br>$$</p>
<p>所以我们可以得到：<br>$$<br>\gcd(a[1],…a[n])&#x3D;\gcd(a[1],a[2]-a[1],…a[n]-a[n-1])<br>$$<br>所以设差分数组为b，区间 $[l,r]$ 的 $\gcd$ 为 $\gcd(a[l],\gcd(b[l+1],…b[r]))$ 把区间修改转换成了单点</p>
<p>下面代码用了线段树和树状数组来维护 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">int</span> n, q;<br>&gt;<span class="hljs-type">int</span> c[N], a[N], b[N];<br>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&gt;&#123;<br><span class="hljs-type">int</span> ans;<br><br>&gt;&#125; tr[N &lt;&lt; <span class="hljs-number">2</span>];<br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">return</span> y ? <span class="hljs-built_in">gcd</span>(y, x % y) : x;<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (l == r)<br>&#123;<br>	tr[p].ans = b[l];<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(lc, l, mid);<br><span class="hljs-built_in">build</span>(rc, mid + <span class="hljs-number">1</span>, r);<br>tr[p].ans = <span class="hljs-built_in">gcd</span>(tr[lc].ans, tr[rc].ans);<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span> <span class="hljs-comment">// 只是单点修改</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (l == r &amp;&amp; r == x)<br>&#123;<br>	tr[p].ans += d;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (x &lt;= mid)<br>	<span class="hljs-built_in">change</span>(lc, l, mid, x, d);<br><span class="hljs-keyword">else</span><br>	<span class="hljs-built_in">change</span>(rc, mid + <span class="hljs-number">1</span>, r, x, d);<br>tr[p].ans = <span class="hljs-built_in">gcd</span>(tr[lc].ans, tr[rc].ans);<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_seg</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y)<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(tr[p].ans);<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (x &lt;= mid)<br>	res = <span class="hljs-built_in">gcd</span>(res, <span class="hljs-built_in">query_seg</span>(lc, l, mid, x, y));<br><span class="hljs-keyword">if</span> (y &gt; mid)<br>	res = <span class="hljs-built_in">gcd</span>(res, <span class="hljs-built_in">query_seg</span>(rc, mid + <span class="hljs-number">1</span>, r, x, y));<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(res);<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">for</span> (; x &lt;= n; x += (x &amp; -x))<br>	c[x] += y;<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_c</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; x; x -= (x &amp; -x))<br>	ans += c[x];<br><span class="hljs-keyword">return</span> ans;<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>cin &gt;&gt; n &gt;&gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>	cin &gt;&gt; a[i];<br>	b[i] = a[i] - a[i - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><span class="hljs-keyword">while</span> (q--)<br>&#123;<br><br>	<span class="hljs-type">char</span> op;<br>	cin &gt;&gt; op;<br>	<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;C&#x27;</span>)<br>	&#123;<br>		<span class="hljs-type">int</span> l, r, d;<br>		cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;<br>		<span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, d);<br>		<span class="hljs-keyword">if</span> (r &lt; n)<br>			<span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, r + <span class="hljs-number">1</span>, -d);<br>		<span class="hljs-built_in">add</span>(l, d), <span class="hljs-built_in">add</span>(r + <span class="hljs-number">1</span>, -d);<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-type">int</span> l, r;<br>		cin &gt;&gt; l &gt;&gt; r;<br>		cout &lt;&lt; <span class="hljs-built_in">gcd</span>(a[l] + <span class="hljs-built_in">query_c</span>(l), <span class="hljs-built_in">query_seg</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l + <span class="hljs-number">1</span>, r)) &lt;&lt; endl;<br>	&#125;<br>&#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>线段树动态开点：一般用于序列长度过长或难以预测，所以搞一棵能维护超长序列的线段树。还有就是作为线段树分裂与合并之类操作的基础</p>
<p>CF915E Physical Education Lessons<br>Alex高中毕业了，他现在是大学新生。虽然他学习编程，但他还是要上体育课，这对他来说完全是一个意外。快要期末了，但是不幸的Alex的体育学分还是零蛋！Alex可不希望被开除，他想知道到期末还有多少天的工作日，这样他就能在这些日子里修体育学分。但是在这里计算工作日可不是件容易的事情：从现在到学期结束还有 $n$ 天(从 $1$ 到 $n$ 编号)，他们一开始都是工作日。接下来学校的工作人员会依次发出 q个指令，每个指令可以用三个参数 $l , r , k$ 描述：<br>如果 $k&#x3D;1$ ，那么从 $l$ 到 $r$ （包含端点）的所有日子都变成非工作日。<br>如果 $k&#x3D;2$ ，那么从 $l$ 到 $r$ （包含端点）的所有日子都变成工作日。<br>帮助Alex统计每个指令下发后，剩余的工作日天数。</p>
<p>关于空间复杂度：<br>设修改次数为 $m$ ，分裂开点时，最坏情况会走两个分支，到叶子节点。所以单次修改最坏开点数为 $2logn$ ，所以，空间复杂度为$O(m·2logn)$。估计内存:$m \times 2logn \times 4 \times 4 &#x3D; 3 \times 10 ^ 5 \times 2 \times log10^9 \times 16&#x3D; 3 \times 10^5 \times 60 \times 16 &#x3D; 288M&gt;250M$ 不要考虑最坏，把 $60$ 变成 $50$ 就行了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = (<span class="hljs-number">3e5</span>) * <span class="hljs-number">50</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	<span class="hljs-type">int</span> lc, rc;<br>	<span class="hljs-type">int</span> lazy; <span class="hljs-comment">// 0工作日 1非工作日 -1清空标记</span><br>	<span class="hljs-type">int</span> sum;<br>&#125; tr[N ];<br><span class="hljs-type">int</span> root, cnt;<br><span class="hljs-comment">// root 表示整棵线段树的根节点；cnt表示当前节点个数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>	tr[p].sum = tr[tr[p].lc].sum + tr[tr[p].rc].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (tr[p].lazy == <span class="hljs-number">-1</span>)<br>		<span class="hljs-keyword">return</span>;<br>	<span class="hljs-keyword">if</span> (!tr[p].lc)<br>		tr[p].lc = ++cnt;<br>	<span class="hljs-keyword">if</span> (!tr[p].rc)<br>		tr[p].rc = ++cnt;<br><br>	<span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>	tr[tr[p].lc].sum = tr[p].lazy * (mid - l + <span class="hljs-number">1</span>);<br>	tr[tr[p].rc].sum = tr[p].lazy * (r - mid);<br>	tr[tr[p].lc].lazy = tr[tr[p].rc].lazy = tr[p].lazy;<br>	tr[p].lazy = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!p)<br>		p = ++cnt;<span class="hljs-comment">//新开点</span><br>	<span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y)<br>	&#123;<br>		tr[p].sum = k * (r - l + <span class="hljs-number">1</span>);<br>		tr[p].lazy = k;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">pushdown</span>(p, l, r);<br>	<span class="hljs-keyword">if</span> (x &lt;= mid)<br>		<span class="hljs-built_in">update</span>(tr[p].lc, l, mid, x, y, k);<br>	<span class="hljs-keyword">if</span> (y &gt; mid)<br>		<span class="hljs-built_in">update</span>(tr[p].rc, mid + <span class="hljs-number">1</span>, r, x, y, k);<br>	<span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (!p)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y)<br>		<span class="hljs-keyword">return</span> tr[p].sum;<br><br>	<span class="hljs-built_in">pushdown</span>(p, l, r);<br>	<span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">if</span> (x &lt;= mid)<br>		sum += <span class="hljs-built_in">query</span>(tr[p].lc, l, mid, x, y);<br>	<span class="hljs-keyword">if</span> (y &gt; mid)<br>		sum += <span class="hljs-built_in">query</span>(tr[p].rc, mid + <span class="hljs-number">1</span>, r, x, y);<br>	<span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; ++i)<br>		tr[i].lazy = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-type">int</span> n, q;<br>	cin &gt;&gt; n &gt;&gt; q;<br>	<span class="hljs-keyword">while</span> (q--)<br>	&#123;<br>		<span class="hljs-type">int</span> l, r, op;<br>		cin &gt;&gt; l &gt;&gt; r &gt;&gt; op;<br>		<span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)<br>			<span class="hljs-built_in">update</span>(root, <span class="hljs-number">1</span>, n, l, r, <span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">else</span><br>			<span class="hljs-built_in">update</span>(root, <span class="hljs-number">1</span>, n, l, r, <span class="hljs-number">0</span>);<br>		cout &lt;&lt; n - <span class="hljs-built_in">query</span>(root, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, n) &lt;&lt; endl;<br>		<span class="hljs-comment">// cout &lt;&lt; n -tr[root].sum &lt;&lt; endl;</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>Codeforces 803G  Periodic RMQ Problem</p>
<p>给你一个序列a 让你支持<br>$1$  $l$  $r$  $x$ 区间赋值<br>$2$  $l$  $r$ 询问区间最小值<br>我们觉得这个问题太水了,所以我们不会给你序列 a,而是给你序列一个长度为 n 的序列 b,把 b复制粘贴 k次就可以得到 a<br>$n ≤ 10^5 , k ≤ 10^4 , q ≤ 10^5 , b_i ≤ 10^9 , 1 ≤ l≤ r ≤ n \times k$</p>
<p>考虑不建树，而使用 ST 表对付查询。如果当前区间已经被覆盖，则返回覆盖的值。否则有 $3$ 种情况：</p>
<ol>
<li>区间的左端点 $l$ 与区间的右端点 $r$ 之差 $\ge n$，即 $r−l+1 \ge n$，这个时候 $[l,r]$ 包含了一个完整的 $b$ 序列，所以中 $[l,r]$ 的数一定只包含 $b$ 中的数，这种情况使用 ST 表查询 $b$ 中 $[0,n−1]$ 的最小值即可。</li>
<li>$r−l+1≤n$ 且 $ ⌊l&#x2F;n⌋&#x3D;⌊r&#x2F;n⌋$。这种情况下， $[l,r]$ 包含 $b$ 中的一段。使用 ST 表查询 $b$ 中 $[l \mod n,r\mod n]$ 最小值即可。</li>
<li>$r−l+1≤n$且 $⌊l&#x2F;n⌋≠⌊r&#x2F;n⌋$。这种情况下，区间 $[l,r]$ 包含 $b$ 中 $[l\mod  n,n−1]$ 和 $[0,r\mod  n]$ 两段。这种情况下答案为两段最小值的最小值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	<span class="hljs-type">int</span> lc, rc;<br>	<span class="hljs-type">int</span> lazy; <span class="hljs-comment">// 0工作日 1非工作日 -1清空标记</span><br>	<span class="hljs-type">int</span> res;<br>&#125; tr[N];<br><span class="hljs-type">int</span> root, cnt;<br><span class="hljs-comment">// root 表示整棵线段树的根节点；cnt表示当前节点个数</span><br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">int</span> f[<span class="hljs-number">100005</span>][<span class="hljs-number">30</span>], lg2[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Ask</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">make</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span><span class="hljs-comment">//开点</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (p)<br>		<span class="hljs-keyword">return</span>;<br>	p = ++cnt;<br>	tr[p].res = <span class="hljs-built_in">Ask</span>(l, r);<span class="hljs-comment">//每一个新节点都是没有标记的（除非父节点会传下来） 于是初始值都是[l,r]的最小值</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>	tr[p].res = <span class="hljs-built_in">min</span>(tr[tr[p].lc].res, tr[tr[p].rc].res);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br> <br>	<span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">make</span>(tr[p].lc, l, mid);<br>	<span class="hljs-built_in">make</span>(tr[p].rc, mid + <span class="hljs-number">1</span>, r);<br>	<span class="hljs-keyword">if</span> (!tr[p].lazy)<br>		<span class="hljs-keyword">return</span>;<br>	tr[tr[p].lc].res = tr[p].lazy;<br>	tr[tr[p].rc].res = tr[p].lazy;<br>	tr[tr[p].lc].lazy = tr[tr[p].rc].lazy = tr[p].lazy;<br>	tr[p].lazy = <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> K = lg2[r - l + <span class="hljs-number">1</span>];<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(f[l][K], f[r - (<span class="hljs-number">1</span> &lt;&lt; K) + <span class="hljs-number">1</span>][K]);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Ask</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &gt;= n)<span class="hljs-comment">//小区间ST表查询</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>, n);<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-comment">/*r - l + 1 &lt; n &amp;&amp;*/</span> (l - <span class="hljs-number">1</span>) / n == (r - <span class="hljs-number">1</span>) / n)<span class="hljs-comment">//大区间ST表查询</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>((l - <span class="hljs-number">1</span>) % n + <span class="hljs-number">1</span>, (r - <span class="hljs-number">1</span>) % n + <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>, (r - <span class="hljs-number">1</span>) % n + <span class="hljs-number">1</span>), <span class="hljs-built_in">ask</span>((l - <span class="hljs-number">1</span>) % n + <span class="hljs-number">1</span>, n));<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">make</span>(p, l, r);<br>	<span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y)<br>	&#123;<br>		tr[p].res = k;<br>		tr[p].lazy = k;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">pushdown</span>(p, l, r);<br>	<span class="hljs-keyword">if</span> (x &lt;= mid)<br>		<span class="hljs-built_in">update</span>(tr[p].lc, l, mid, x, y, k);<br>	<span class="hljs-keyword">if</span> (y &gt; mid)<br>		<span class="hljs-built_in">update</span>(tr[p].rc, mid + <span class="hljs-number">1</span>, r, x, y, k);<br>	<span class="hljs-built_in">pushup</span>(p);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">make</span>(p, l, r);<br>	<span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y)<br>		<span class="hljs-keyword">return</span> tr[p].res;<br> <br>	<span class="hljs-built_in">pushdown</span>(p, l, r);<br>	<span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> res = inf;<br>	<span class="hljs-keyword">if</span> (x &lt;= mid)<br>		res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">query</span>(tr[p].lc, l, mid, x, y));<br>	<span class="hljs-keyword">if</span> (y &gt; mid)<br>		res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">query</span>(tr[p].rc, mid + <span class="hljs-number">1</span>, r, x, y));<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>		tr[i].res = inf;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)<br>		lg2[i] = lg2[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= lg2[n]; ++j)<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>)) &lt;= n; ++i)<br>		&#123;<br>			f[i][j] = <span class="hljs-built_in">min</span>(f[i][j - <span class="hljs-number">1</span>], f[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>		&#125;<br>	&#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <br>	cin &gt;&gt; n &gt;&gt; k;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		cin &gt;&gt; f[i][<span class="hljs-number">0</span>];<br> <br>	<span class="hljs-built_in">init</span>();<br> <br>	<span class="hljs-built_in">make</span>(root, <span class="hljs-number">1</span>, n * k);<br>	<span class="hljs-type">int</span> q;<br>	cin &gt;&gt; q;<br>	<span class="hljs-keyword">while</span> (q--)<br>	&#123;<br>		<span class="hljs-type">int</span> op;<br>		cin &gt;&gt; op;<br>		<span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)<br>		&#123;<br>			<span class="hljs-type">int</span> l, r, x;<br>			cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;<br>			<span class="hljs-built_in">update</span>(root, <span class="hljs-number">1</span>, n * k, l, r, x);<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-type">int</span> l, r;<br>			cin &gt;&gt; l &gt;&gt; r;<br>			cout &lt;&lt; <span class="hljs-built_in">query</span>(root, <span class="hljs-number">1</span>, n * k, l, r) &lt;&lt; endl;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>树的DFS序:简单来讲就是对树从根开始进行深搜，按搜到的时间顺序把所有节点排队。DFS序的一个性质就是把一棵子树放在一个区间里。这个优秀的性质把树状结构变成了线性结构，可以转化成区间操作。方便我们进行统计。所以如果一个点的起始时间和终结时间被另一个点包括，这个点肯定是另一个点的子节点。利用DFS序我们可以对节点下面的所有结点进行操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><span class="hljs-comment">//链式前向星</span><br>&#123;<br>	<span class="hljs-type">int</span> v, ne;<br>&#125;;<br>edge e[N];	   <span class="hljs-comment">// 边集</span><br><span class="hljs-type">int</span> idx, h[N]; <span class="hljs-comment">// 点的第一条出边</span><br><span class="hljs-type">int</span> tim,out[N],in[N],pos[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>	e[++idx] = &#123;b, h[a]&#125;;<br>	h[a] = idx;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>	tim++;<br>	in[u]=tim;<br>	pos[tim]=u;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = e[i].ne)<br>	&#123;<br>		<span class="hljs-type">int</span> v = e[i].v;<br>		<span class="hljs-keyword">if</span> (v == fa)<br>			<span class="hljs-keyword">continue</span>;<br>        <br>		<span class="hljs-built_in">dfs</span>(v, u);<br>	&#125;<br>	out[u]=tim;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(memset(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);)</span></span><br></code></pre></td></tr></table></figure></blockquote>
<blockquote>
<p> 扫描线算法&#x2F;矩形面积并</p>
<ol>
<li><p>扫描线就是一根线，从下向上扫，以每个矩形的上下边为界可以把 $n$ 个矩形组成的区域分割成 $2n-1$ 个区块。</p>
</li>
<li><p>区块高度就是扫过的距离，即 $Y_i+1-Y_i$。</p>
</li>
<li><p>区块长度就是区块内矩形长度的并，即 $len_i$。</p>
</li>
<li><p>面积并 $&#x3D; \sum{len_i*(Y_i+1-Y_i)}$。区块长度可以用线段树维护。每当扫到一个矩形的下边时就加入该矩形长度的贡献;而当扫到这个矩形的上边时，就减去该矩形长度的贡献。</p>
</li>
<li><p>区块长度需要通过矩形的 $X$ 坐标来拼凑。但是，所给矩形的 $X$ 坐标“值域大($10^9$)，数量少($10^5$)”，需要离散化。离散化就是把“稀疏的数”映射成“连续的整数”</p>
</li>
<li><p>传参时，右端点向左偏一下,计算时，右端点向右偏一下。区块长度 &#x3D; <code>tr[1].len</code>。</p>
<p><img src="C:\Users\LYT\Documents\cpp\File_Markdown\scanlines.jpg" srcset="/img/loading.gif" lazyload alt="scanlines"></p>
</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> <span class="hljs-comment">// 扫描线</span><br>&#123;<br>	<span class="hljs-type">int</span> x1, x2, y;<br>	<span class="hljs-type">int</span> tag; <span class="hljs-comment">// 入边+1 出边-1</span><br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(Line &amp;t)<br>	&#123;<br>		<span class="hljs-keyword">return</span> y &lt; t.y;<br>	&#125;<br>&#125; L[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	<span class="hljs-type">int</span> l, r;<br>	<span class="hljs-type">int</span> cnt, len; <span class="hljs-comment">// 区间覆盖次数和覆盖长度</span><br><br>&#125; tr[<span class="hljs-number">4</span> * N];<br><span class="hljs-type">int</span> x[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> l = tr[p].l, r = tr[p].r;<br>	<span class="hljs-keyword">if</span> (tr[p].cnt)<br>		tr[p].len = x[r + <span class="hljs-number">1</span>] - x[l];<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">if</span> (l != r)<br>			tr[p].len = tr[lc].len + tr[rc].len;<br>		<span class="hljs-keyword">else</span><br>			tr[p].len = <span class="hljs-number">0</span>;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> tag)</span> <span class="hljs-comment">// 区间修改</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (x &gt; tr[p].r || y &lt; tr[p].l)<br>		<span class="hljs-keyword">return</span>;<br>	<span class="hljs-keyword">if</span> (x &lt;= tr[p].l &amp;&amp; tr[p].r &lt;= y)<br>	&#123;<br>		tr[p].cnt += tag;<br>		<span class="hljs-built_in">pushup</span>(p);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">update</span>(lc, x, y, tag);<br>	<span class="hljs-built_in">update</span>(rc, x, y, tag);<br>	<span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> <span class="hljs-comment">// 建树</span></span><br><span class="hljs-function"></span>&#123;<br>	tr[p] = &#123;l, r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>	<span class="hljs-keyword">if</span> (l == r)<br>		<span class="hljs-keyword">return</span>;<br>	<span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">build</span>(lc, l, mid);<br>	<span class="hljs-built_in">build</span>(rc, mid + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n, ans = <span class="hljs-number">0</span>;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> x1, y1, x2, y2;<br>		cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br>		L[i] = &#123;x1, x2, y1, <span class="hljs-number">1</span>&#125;;<br>		L[n + i] = &#123;x1, x2, y2, <span class="hljs-number">-1</span>&#125;;<br>		x[i] = x1, x[n + i] = x2;<br>	&#125;<br>	n *= <span class="hljs-number">2</span>;<br>	<span class="hljs-built_in">sort</span>(L + <span class="hljs-number">1</span>, L + <span class="hljs-number">1</span> + n);					  <span class="hljs-comment">// 扫描线排序</span><br>	<span class="hljs-built_in">sort</span>(x + <span class="hljs-number">1</span>, x + <span class="hljs-number">1</span> + n);					  <span class="hljs-comment">// x坐标排序</span><br>	<span class="hljs-type">int</span> s = <span class="hljs-built_in">unique</span>(x + <span class="hljs-number">1</span>, x + <span class="hljs-number">1</span> + n) - x - <span class="hljs-number">1</span>;   <span class="hljs-comment">// 去重</span><br>	<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, s - <span class="hljs-number">1</span>);<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> l = <span class="hljs-built_in">lower_bound</span>(x + <span class="hljs-number">1</span>, x + <span class="hljs-number">1</span> + s, L[i].x1) - x;<br>		<span class="hljs-type">int</span> r = <span class="hljs-built_in">lower_bound</span>(x + <span class="hljs-number">1</span>, x + <span class="hljs-number">1</span> + s, L[i].x2) - x;<br>		<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, l, r - <span class="hljs-number">1</span>, L[i].tag);<br>		ans += tr[<span class="hljs-number">1</span>].len * (L[i + <span class="hljs-number">1</span>].y - L[i].y);<br>	&#125;<br>	cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="7-可持久化线段树（主席树）"><a href="#7-可持久化线段树（主席树）" class="headerlink" title="7.可持久化线段树（主席树）"></a>7.可持久化线段树（主席树）</h3><blockquote>
<p>洛谷P3834</p>
<p>这是个非常经典的可持久化权值线段树入门题——静态区间第 $k$ 小。<br>如题，给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> lc(x) tr[x].l</span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">define</span> rc(x) tr[x].r</span><br>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&gt;&#123;<br><span class="hljs-type">int</span> l, r, s; <span class="hljs-comment">// s:节点值域中有多少个数</span><br>&gt;&#125; tr[N * <span class="hljs-number">20</span>];<br>&gt;<span class="hljs-type">int</span> root[N], idx; <span class="hljs-comment">// root 每一个版本的根节点编号 , idx 节点编号</span><br>&gt;<span class="hljs-type">int</span> n, m, a[N];<br>&gt;vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>x = ++idx;<br><span class="hljs-keyword">if</span> (l == r)<br>	<span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(<span class="hljs-built_in">lc</span>(x), l, m);<br><span class="hljs-built_in">build</span>(<span class="hljs-built_in">rc</span>(x), m + <span class="hljs-number">1</span>, r);<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> &amp;y, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>y = ++idx;<br>tr[y] = tr[x];<br>tr[y].s++;<br><span class="hljs-keyword">if</span> (l == r)<br>	<span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (k &lt;= m)<br>	<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">lc</span>(x), <span class="hljs-built_in">lc</span>(y), l, m, k);<br><span class="hljs-keyword">else</span><br>	<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">rc</span>(x), <span class="hljs-built_in">rc</span>(y), m + <span class="hljs-number">1</span>, r, k);<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">if</span> (l == r)<br>	<span class="hljs-keyword">return</span> l;<br><span class="hljs-type">int</span> m = l + r &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// x y同步</span><br><span class="hljs-type">int</span> s = tr[<span class="hljs-built_in">lc</span>(y)].s - tr[<span class="hljs-built_in">lc</span>(x)].s;<br><span class="hljs-keyword">if</span> (k &lt;= s)<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-built_in">lc</span>(x), <span class="hljs-built_in">lc</span>(y), l, m, k);<br><span class="hljs-keyword">else</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-built_in">rc</span>(x), <span class="hljs-built_in">rc</span>(y), m + <span class="hljs-number">1</span>, r, k - s);<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getid</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), x) - v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br>&gt;&#125;<br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>	cin &gt;&gt; a[i], v.<span class="hljs-built_in">push_back</span>(a[i]);<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//离散化</span><br>v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-type">int</span> lenv = v.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-built_in">build</span>(root[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, lenv);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>	<span class="hljs-built_in">insert</span>(root[i - <span class="hljs-number">1</span>], root[i], <span class="hljs-number">1</span>, lenv, <span class="hljs-built_in">getid</span>(a[i]));<br><span class="hljs-keyword">while</span> (m--)<br>&#123;<br>	<span class="hljs-type">int</span> l, r, k;<br>	cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;<br>	<span class="hljs-type">int</span> id = <span class="hljs-built_in">query</span>(root[l - <span class="hljs-number">1</span>], root[r], <span class="hljs-number">1</span>, lenv, k) - <span class="hljs-number">1</span>;<br>	cout &lt;&lt; v[id] &lt;&lt; endl;<br>&#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<h3 id="8-二叉查找树"><a href="#8-二叉查找树" class="headerlink" title="8..二叉查找树"></a>8..二叉查找树</h3><blockquote>
<p>二叉查找树,是一种能存储特定数据类型的容器。二叉查找树允许快速查找、插入或者删除某一个节点。<br>重要性质:左小右大，中序遍历是有序的</p>
<p>Splay(伸展树)是一种平衡二叉树，它通过不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，并且保持平衡而不至于退化为链，同时也是一个权值树 (值域在1e7之间)。</p>
<p><img src="C:\Users\LYT\Documents\cpp\File_Markdown\Splay_rotate.png" srcset="/img/loading.gif" lazyload alt="Splay_rotate"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(x) tr[x].ch[0]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(x) tr[x].ch[1]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	<span class="hljs-type">int</span> ch[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 儿</span><br>	<span class="hljs-type">int</span> fa;	   <span class="hljs-comment">// 父</span><br>	<span class="hljs-type">int</span> v;	   <span class="hljs-comment">// 点权</span><br>	<span class="hljs-type">int</span> cnt;   <span class="hljs-comment">// 权值出现的次数</span><br>	<span class="hljs-type">int</span> siz;   <span class="hljs-comment">// 子树大小</span><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> v1)</span></span><br><span class="hljs-function">	</span>&#123;<br>		fa = p, v = v1;<br>		cnt = siz = <span class="hljs-number">1</span>;<br>	&#125;<br>&#125; tr[N];<br><span class="hljs-type">int</span> root, tot; <span class="hljs-comment">// 根,节点个数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 上传</span><br>	tr[x].siz = tr[<span class="hljs-built_in">ls</span>(x)].siz + tr[<span class="hljs-built_in">rs</span>(x)].siz + tr[x].cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;															   <span class="hljs-comment">// 旋转</span><br>	<span class="hljs-type">int</span> y = tr[x].fa, z = tr[y].fa, k = tr[y].ch[<span class="hljs-number">1</span>] == x;	   <span class="hljs-comment">// y的右儿是x</span><br>	tr[z].ch[tr[z].ch[<span class="hljs-number">1</span>] == y] = x, tr[x].fa = z;			   <span class="hljs-comment">// z的儿是x,x的父是z</span><br>	tr[y].ch[k] = tr[x].ch[k ^ <span class="hljs-number">1</span>], tr[tr[x].ch[k ^ <span class="hljs-number">1</span>]].fa = y; <span class="hljs-comment">// y的儿是x的异儿,x的异儿的父是y</span><br>	tr[x].ch[k ^ <span class="hljs-number">1</span>] = y, tr[y].fa = x;						   <span class="hljs-comment">// x的异儿是y,y的父是x</span><br>	<span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);									   <span class="hljs-comment">// 自底向上push</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 伸展 访问一个节点x 并把x旋转到根节点</span><br>	<span class="hljs-keyword">while</span> (tr[x].fa != k)<br>	&#123; <span class="hljs-comment">// 折线转xx,直线转yx</span><br>		<span class="hljs-type">int</span> y = tr[x].fa, z = tr[y].fa;<br>		<span class="hljs-keyword">if</span> (z != k)<br>			(<span class="hljs-built_in">ls</span>(y) == x) ^ (<span class="hljs-built_in">ls</span>(z) == y) ? <span class="hljs-built_in">rotate</span>(x) : <span class="hljs-built_in">rotate</span>(y);<br>		<span class="hljs-built_in">rotate</span>(x);<br>	&#125;<br>	<span class="hljs-keyword">if</span> (!k)<br>		root = x; <span class="hljs-comment">// k=0时,x转到根</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 插入(权值)</span><br>	<span class="hljs-type">int</span> x = root, p = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// x走到空节点或走到目标点结束</span><br>	<span class="hljs-keyword">while</span> (x &amp;&amp; tr[x].v != v)<br>		p = x, x = tr[x].ch[v &gt; tr[x].v];<br>	<span class="hljs-keyword">if</span> (x)<br>		tr[x].cnt++; <span class="hljs-comment">// 目标点情况</span><br>	<span class="hljs-keyword">else</span><br>	&#123; <span class="hljs-comment">// 空节点情况</span><br>		x = ++tot;<br>		tr[p].ch[v &gt; tr[p].v] = x;<br>		tr[x].<span class="hljs-built_in">init</span>(p, v);<br>	&#125;<br>	<span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 找到v并转到根(权值)</span><br>	<span class="hljs-type">int</span> x = root;<br>	<span class="hljs-keyword">while</span> (tr[x].ch[v &gt; tr[x].v] &amp;&amp; v != tr[x].v)<br>		x = tr[x].ch[v &gt; tr[x].v];<br>	<span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getpre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 前驱 返回其节点编号 (权值)</span><br>	<span class="hljs-built_in">find</span>(v);<br>	<span class="hljs-type">int</span> x = root;<br>	<span class="hljs-keyword">if</span> (tr[x].v &lt; v)<br>		<span class="hljs-keyword">return</span> x;<br>	x = <span class="hljs-built_in">ls</span>(x);<br>	<span class="hljs-keyword">while</span> (<span class="hljs-built_in">rs</span>(x))<br>		x = <span class="hljs-built_in">rs</span>(x);<br>	<span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsuc</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 后继 返回其节点编号 (权值)</span><br>	<span class="hljs-built_in">find</span>(v);<br>	<span class="hljs-type">int</span> x = root;<br>	<span class="hljs-keyword">if</span> (tr[x].v &gt; v)<br>		<span class="hljs-keyword">return</span> x;<br>	x = <span class="hljs-built_in">rs</span>(x);<br>	<span class="hljs-keyword">while</span> (<span class="hljs-built_in">ls</span>(x))<br>		x = <span class="hljs-built_in">ls</span>(x);<br>	<span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 删除v (权值)若有多个相同的数，只删除一个</span><br>	<span class="hljs-type">int</span> pre = <span class="hljs-built_in">getpre</span>(v);<br>	<span class="hljs-type">int</span> suc = <span class="hljs-built_in">getsuc</span>(v);<br>	<span class="hljs-built_in">splay</span>(pre, <span class="hljs-number">0</span>), <span class="hljs-built_in">splay</span>(suc, pre);<br>	<span class="hljs-type">int</span> del = tr[suc].ch[<span class="hljs-number">0</span>];<br>	<span class="hljs-keyword">if</span> (tr[del].cnt &gt; <span class="hljs-number">1</span>)<br>		tr[del].cnt--, <span class="hljs-built_in">splay</span>(del, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">else</span><br>		tr[suc].ch[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, <span class="hljs-built_in">splay</span>(suc, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getrank</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 排名 (权值) 查询v数的排名</span><br>	<span class="hljs-built_in">insert</span>(v);<br>	<span class="hljs-type">int</span> res = tr[tr[root].ch[<span class="hljs-number">0</span>]].siz;<br>	<span class="hljs-built_in">del</span>(v);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getval</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 数值 查询排名为k的数值(但实际使用中，由于哨兵存在 需要 getval(k+1))</span><br>	<span class="hljs-type">int</span> x = root;<br>	<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (k &lt;= tr[<span class="hljs-built_in">ls</span>(x)].siz)<br>			x = <span class="hljs-built_in">ls</span>(x);<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt;= tr[<span class="hljs-built_in">ls</span>(x)].siz + tr[x].cnt)<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">else</span><br>			k -= tr[<span class="hljs-built_in">ls</span>(x)].siz + tr[x].cnt, x = <span class="hljs-built_in">rs</span>(x);<br>	&#125;<br>	<span class="hljs-built_in">splay</span>(x, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">return</span> tr[x].v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">insert</span>(-inf),<span class="hljs-built_in">insert</span>(inf);<span class="hljs-comment">//充当哨兵，省去判断步骤</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="9-珂朵莉树"><a href="#9-珂朵莉树" class="headerlink" title="9.珂朵莉树"></a>9.珂朵莉树</h3><blockquote>
<p> 其核心思想是将值相同的一段区间合并成一个结点处理。相较于传统的线段树等数据结构，对于含有区间覆盖的操作的问题，珂朵莉树可以更加方便地维护每个被覆盖区间的值。一种暴力数据结构。</p>
<p> n 个数， m 次操作 $(n,m&lt;&#x3D;10^5)$  。数据随机，时限 2s 。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	<span class="hljs-type">int</span> l, r;<br>	<span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> v; <span class="hljs-comment">// 数值</span><br>	<span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R = <span class="hljs-number">-1</span>, <span class="hljs-type">int</span> V = <span class="hljs-number">0</span>) : <span class="hljs-built_in">l</span>(L), <span class="hljs-built_in">r</span>(R), <span class="hljs-built_in">v</span>(V) &#123;&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node &amp;o) <span class="hljs-type">const</span> <span class="hljs-comment">// 重载运算符</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> l &lt; o.l;<br>	&#125;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IT set<span class="hljs-string">&lt;node&gt;</span>::iterator</span><br>set&lt;node&gt; s;<br><span class="hljs-function">IT <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> <span class="hljs-comment">// 分裂</span></span><br><span class="hljs-function"></span>&#123;<br>	IT it = s.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">node</span>(pos));  <span class="hljs-comment">// 找到首个不小于pos的set</span><br>	<span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">end</span>() &amp;&amp; it-&gt;l == pos) <span class="hljs-comment">// 无需，直接返回</span><br>		<span class="hljs-keyword">return</span> it;<br>	--it;									<span class="hljs-comment">// 否则一定在前一个区间中</span><br>	<span class="hljs-type">int</span> L = it-&gt;l, R = it-&gt;r;				<span class="hljs-comment">// 【l,r】就是要分裂的区间</span><br>	<span class="hljs-type">int</span> V = it-&gt;v;							<span class="hljs-comment">// 取出值</span><br>	s.<span class="hljs-built_in">erase</span>(it);							<span class="hljs-comment">// 删除原集合</span><br>	s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(L, pos - <span class="hljs-number">1</span>, V));			<span class="hljs-comment">// 构建前半段的新结合</span><br>	<span class="hljs-keyword">return</span> s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(pos, R, V)).first; <span class="hljs-comment">// 构建后半段的新集合并且返回地址</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign_val</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> <span class="hljs-comment">// 推平操作</span></span><br><span class="hljs-function"></span>&#123;<br>	IT itl = <span class="hljs-built_in">split</span>(r + <span class="hljs-number">1</span>), itr = <span class="hljs-built_in">split</span>(l); <span class="hljs-comment">// 求出要被摊平区间的首尾地址 左闭右开？先是右节点 再是左节点</span><br>	s.<span class="hljs-built_in">erase</span>(itr, itl);					   <span class="hljs-comment">// 删除原集合</span><br>	s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(l, r, val));			   <span class="hljs-comment">// 添加新集合</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> <span class="hljs-comment">// 区间加</span></span><br><span class="hljs-function"></span>&#123;<br>	IT itr = <span class="hljs-built_in">split</span>(r + <span class="hljs-number">1</span>), itl = <span class="hljs-built_in">split</span>(l);<br>	<span class="hljs-keyword">for</span> (; itl != itr; ++itl)<br>		itl-&gt;v += val;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rank</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> <span class="hljs-comment">// 区间第k小</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; vp;<br>	IT itr = <span class="hljs-built_in">split</span>(r + <span class="hljs-number">1</span>), itl = <span class="hljs-built_in">split</span>(l);<br>	vp.<span class="hljs-built_in">clear</span>();<br>	<span class="hljs-keyword">for</span> (; itl != itr; ++itl)<br>		vp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(itl-&gt;v, itl-&gt;r - itl-&gt;l + <span class="hljs-number">1</span>));<br>	<span class="hljs-built_in">sort</span>(vp.<span class="hljs-built_in">begin</span>(), vp.<span class="hljs-built_in">end</span>());<br>	<span class="hljs-keyword">for</span> (vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;::iterator it = vp.<span class="hljs-built_in">begin</span>(); it != vp.<span class="hljs-built_in">end</span>(); ++it)<br>	&#123;<br>		k -= it-&gt;second;<br>		<span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span>)<br>			<span class="hljs-keyword">return</span> it-&gt;first;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pown</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> mod)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans = a % mod;<br>    <span class="hljs-keyword">while</span> (b)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b&amp;<span class="hljs-number">1</span>) <br>            res = res * ans % mod;<br>        ans = ans * ans % mod;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> ex, <span class="hljs-type">int</span> mod)</span><span class="hljs-comment">//区间幂次和</span></span><br><span class="hljs-function"></span>&#123;<br>    IT itr = <span class="hljs-built_in">split</span>(r + <span class="hljs-number">1</span>), itl = <span class="hljs-built_in">split</span>(l);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; itl != itr; ++itl)<br>        res = (res + (itl-&gt;r - itl-&gt;l + <span class="hljs-number">1</span>) * <span class="hljs-built_in">pown</span>(itl-&gt;v, ex, mod)) % mod;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n, m;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">5</span>));<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> l, r;<br>		cin &gt;&gt; l &gt;&gt; r;<br>		<span class="hljs-built_in">assign_val</span>(l, r, i);<br>	&#125;<br><br>	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>	IT itr = <span class="hljs-built_in">split</span>(n + <span class="hljs-number">1</span>), itl = <span class="hljs-built_in">split</span>(<span class="hljs-number">1</span>);<br>	map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; vis;<br>	<span class="hljs-keyword">for</span> (; itl != itr; ++itl)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (!vis[itl-&gt;v] &amp;&amp; <span class="hljs-number">1</span> &lt;= itl-&gt;v &amp;&amp; itl-&gt;v &lt;= m)<br>		&#123;<br>			vis[itl-&gt;v] = <span class="hljs-literal">true</span>;<br>			ans++;<br>		&#125;<br>	&#125;<br>	cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<h2 id="二、图论"><a href="#二、图论" class="headerlink" title="二、图论"></a>二、图论</h2><h3 id="1-图的存储"><a href="#1-图的存储" class="headerlink" title="1.图的存储"></a>1.图的存储</h3><blockquote>
<ul>
<li><p>邻接矩阵 只在点数不多的稠密图(n&#x3D;1e3,m&#x3D;1e6)上使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> w[N][N];<br><span class="hljs-type">int</span> vis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>	vis[u]=<span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">1</span>;v&lt;=n;++v)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(w[u][v])<br>		&#123;<br>			cout&lt;&lt;u&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;v&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;w[u][v];<br>			<span class="hljs-keyword">if</span>(vis[v])	<span class="hljs-comment">//判重</span><br>				<span class="hljs-keyword">continue</span>;<br>			<span class="hljs-built_in">dfs</span>(v);<br>		&#125;<br><br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>	&#123;<br>		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>		w[a][b]=c;<br>		<span class="hljs-comment">//w[b][a]=c; 	//无向</span><br>	&#125;<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>边集数组 <code>e[i]</code>存储第i条边的<code>[起点u，终点v，边权w]</code>, 在kruskal算法中，需要将边按边权排序，直接存边</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp">   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>   &#123;<br>   	<span class="hljs-type">int</span> u,v,w;<br>   &#125;e[M];<br>   <span class="hljs-type">int</span> vis[N];<br><br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function">   </span>&#123;<br>   	vis[u]=<span class="hljs-literal">true</span>;<br>   	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>   	&#123;<br>   		<span class="hljs-keyword">if</span>(e[i].u==u)<br>   		&#123;<br>   			<span class="hljs-type">int</span> v=e[i].v,w=e[i].w;<br>   			cout&lt;&lt;u&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;v&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;w&lt;&lt;endl;<br>   			<span class="hljs-keyword">if</span>(vis[v])	<span class="hljs-keyword">continue</span>;<br>   			<span class="hljs-built_in">dfs</span>(e[i].v);<br>   		&#125;<br>    	&#125;    <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">   </span>&#123;<br>      	cin &gt;&gt; n &gt;&gt; m ;<br>      	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; ++i)<br>      	&#123;<br>      		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>      		e[i]=&#123;a,b,c&#125;;<br>      		<span class="hljs-comment">//e[i]=&#123;b,a,c&#125;;</span><br>      	&#125;<br>      	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>   &#125;<br><br>*  邻接表 出边数组`e[u][i]`存储u点所有出边的`[终点v，边权w]`<br><br>  ```cpp<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;;<br>  vector&lt;edge&gt; e[N];<span class="hljs-comment">//边集</span><br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span><span class="hljs-comment">//fa u的父节点</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed : e[u])<br>     &#123;<br>  	<span class="hljs-type">int</span> v=ed.v, w=ed.w;<br>  	<span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<br>  	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>,u,v,w);<br>  	<span class="hljs-built_in">dfs</span>(v, u);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>  	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c,<br>  	e[a].<span class="hljs-built_in">push_back</span>(&#123;b,c&#125;);<br>  	e[b].<span class="hljs-built_in">push_back</span>(&#123;a,c&#125;);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>链式邻接表 边集数组<code>e[j]</code>存储第<code>j</code>条边的<code>[起点u,终点v，边权w]</code>，表头数组<code>h[u][i]</code>存储点的所有出边的编号，能处理反向边。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m, a, b, c;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>	<span class="hljs-type">int</span> u, v, w;<br>&#125;;<br>vector&lt;edge&gt; e;	  <span class="hljs-comment">// 边集</span><br>vector&lt;<span class="hljs-type">int</span>&gt; h[N]; <span class="hljs-comment">// 点的所有出边</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>	e.<span class="hljs-built_in">push_back</span>(&#123;a, b, c&#125;);<br>	h[a].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h[u].<span class="hljs-built_in">size</span>(); i++)<br>	&#123;<br>		<span class="hljs-type">int</span> j = h[u][i];<br>		<span class="hljs-type">int</span> v = e[j].v, w = e[j].w;<br>		<span class="hljs-keyword">if</span> (v == fa)<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>, u, v, w);<br>		<span class="hljs-built_in">dfs</span>(v, u);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>	&#123;<br>		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c,<br>			<span class="hljs-built_in">add</span>(a, b, c);<br>		<span class="hljs-built_in">add</span>(b, a, c);<br>	&#125;<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>链式前向星   一个表头数组悬挂多个链表，边集数组<code>e[i]</code>存储第<code>i</code>条出边的<code>[终点v，边权w，下一条边ne]</code>，表头数组<code>h[u]</code>存储<code>u</code>点的第一条出边的编号,边的编号<code>idx</code>可取0，1，2，3。可以处理反向边。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>	<span class="hljs-type">int</span> v, w, ne;<br>&#125;;<br>edge e[M];	   <span class="hljs-comment">// 边集</span><br><span class="hljs-type">int</span> idx, h[N]; <span class="hljs-comment">// 点的第一条出边</span><br>                                                                                                                                                          <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>	e[idx] = &#123;b, c, h[a]&#125;;<br>	h[a] = idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; ~i; i = e[i].ne)<br>	&#123;<br>		<span class="hljs-type">int</span> v = e[i].v, w = e[i].w;<br>		<span class="hljs-keyword">if</span> (v == fa)<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>, u, v, w);<br>		<span class="hljs-built_in">dfs</span>(v, u);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>	&#123;<br>		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c,<br>			<span class="hljs-built_in">add</span>(a, b, c);<br>		<span class="hljs-built_in">add</span>(b, a, c);<br>	&#125;<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h3 id="2-广度优先搜索（bfs）"><a href="#2-广度优先搜索（bfs）" class="headerlink" title="2.广度优先搜索（bfs）"></a>2.广度优先搜索（bfs）</h3><blockquote>
<p>模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>node t;<br>t.x = x, t.y = y;<br>queue&lt;node&gt; q;<br>q.<span class="hljs-built_in">push</span>(t);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>	node t = q.<span class="hljs-built_in">front</span>();<br>	q.<span class="hljs-built_in">pop</span>();<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> xx = t.x + dx[i];<br>		<span class="hljs-type">int</span> yy = t.y + dy[i];<br>		<span class="hljs-keyword">if</span> (xx &lt; <span class="hljs-number">1</span> || xx &gt; n || yy &lt; <span class="hljs-number">1</span> || yy &gt; n || vis[xx][yy])<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">if</span> (g[xx][yy] == <span class="hljs-string">&#x27;P&#x27;</span>)<br>			flag = <span class="hljs-literal">true</span>;<br>		vis[xx][yy] = <span class="hljs-literal">true</span>;<br>		q.<span class="hljs-built_in">push</span>(&#123;xx, yy&#125;);<br>	&#125;<br>&#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="3-最短路算法"><a href="#3-最短路算法" class="headerlink" title="3.最短路算法"></a>3.最短路算法</h3><blockquote>
<p>dijkstra算法 单源最短路算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-comment">// 小根堆优化</span><br>&gt;<span class="hljs-comment">// d[i]  从st到i的最短距离</span><br>&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&gt;&#123;<br><span class="hljs-type">int</span> x, w;							<span class="hljs-comment">// x表示出点，w表示权值</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node &amp;v) <span class="hljs-type">const</span> <span class="hljs-comment">// 按照w小的优先</span><br>&#123;<br>	<span class="hljs-keyword">return</span> w == v.w ? x &lt; v.x : w &gt; v.w;<br>&#125;<br>&gt;&#125;;<br>&gt;vector&lt;node&gt; e[N];<br>&gt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> d[N], n, m;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(d));<br>d[st] = <span class="hljs-number">0</span>;	   <span class="hljs-comment">// 初始化起点</span><br>bitset&lt;N&gt; vis; <span class="hljs-comment">// 表示已经拓展过</span><br>priority_queue&lt;node&gt; pq;<br>pq.<span class="hljs-built_in">push</span>(&#123;st, d[st]&#125;); <span class="hljs-comment">// 把起点作为拓展点</span><br><br><span class="hljs-keyword">while</span> (pq.<span class="hljs-built_in">size</span>())<br>&#123;<br>	<span class="hljs-type">int</span> t = pq.<span class="hljs-built_in">top</span>().x;<br>	pq.<span class="hljs-built_in">pop</span>();<br>	<span class="hljs-keyword">if</span> (vis[t])<br>		<span class="hljs-keyword">continue</span>;<br>	vis[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 取出的t点已经得到了最短距离d[x]</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[y, w] : e[t])<br>	&#123;<br>		<span class="hljs-keyword">if</span> (!vis[y] &amp;&amp; d[y] &gt; d[t] + w) <span class="hljs-comment">// 如果vis[y] 说明y已经得到最短距离 无需更新</span><br>		&#123;<br>			d[y] = d[t] + w;<br>			pq.<span class="hljs-built_in">push</span>(&#123;y, d[y]&#125;);<br>		&#125;<br>	&#125;<br>&#125;<br>&gt;&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<blockquote>
<p>floyd算法 时间复杂度O(n^3) 多源最短路</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">long</span> d[N][N], n, m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(d));<br><br>	<span class="hljs-comment">// 初始化</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		d[i][i] = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; ++k) <span class="hljs-comment">// 中转点在第一行</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)<br>				d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="4-最小生成树"><a href="#4-最小生成树" class="headerlink" title="4.最小生成树"></a>4.最小生成树</h3><blockquote>
<p>kruskal算法 利用并查集求最小生成树 对边权进行从小到大排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>	<span class="hljs-type">int</span> u, v, w;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> edge &amp;t) <span class="hljs-type">const</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> w &lt; t.w;<br>	&#125;<br>&#125; e[N];<br><span class="hljs-type">int</span> fa[N], ans, cnt, m, n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (fa[x] == x)<br>		<span class="hljs-keyword">return</span> x;<br>	<span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">sort</span>(e, e + m);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		fa[i] = i;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(e[i].u);<br>		<span class="hljs-type">int</span> y = <span class="hljs-built_in">find</span>(e[i].v);<br>		<span class="hljs-keyword">if</span> (x != y)<br>		&#123;<br>			fa[x] = y;<br>			ans += e[i].w;<br>			cnt++;<br>		&#125;<br><br>	&#125;<br>	<span class="hljs-keyword">return</span> cnt == n - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>prim算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// d[u]存与圈外邻点的最小距离，vis[u]标记u点是否出圈</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>	<span class="hljs-type">int</span> v;<br>	<span class="hljs-type">double</span> w;<br><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	<span class="hljs-type">double</span> d;<br>	<span class="hljs-type">int</span> v;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node &amp;t)<span class="hljs-type">const</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> v&gt;t.v;<br>	&#125;<br>&#125;;<br><br>vector&lt;edge&gt; e[N];<br><span class="hljs-type">int</span> d[N], vis[N], ans = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>, n;<br>priority_queue&lt;node&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)<br>		d[i] = inf;<br>	d[s] = <span class="hljs-number">0</span>;<br>	q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br>	<span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>	&#123;<br>		<span class="hljs-type">int</span> u = q.<span class="hljs-built_in">top</span>().v;<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span> (vis[u])<br>			<span class="hljs-keyword">continue</span>;<br>		vis[u] = <span class="hljs-number">1</span>;<br>		ans += d[u];<br>		cnt++;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ed : e[u])<br>		&#123;<br>			<span class="hljs-type">int</span> v = ed.v, w = ed.w;<br>			<span class="hljs-keyword">if</span> (d[v] &gt; w)<br>			&#123;<br>				d[v] = w;<br>				q.<span class="hljs-built_in">push</span>(&#123;d[v], v&#125;);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> cnt == n;<br>&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<h3 id="5-Tarjan-强连通分量（SCC）"><a href="#5-Tarjan-强连通分量（SCC）" class="headerlink" title="5.Tarjan  强连通分量（SCC）"></a>5.Tarjan  强连通分量（SCC）</h3><blockquote>
<p>tarjan算法求强连通分量(Strongly Connected Components , SCC) 极大的强连通子图<br>对图深搜时，每个节点只访问一次，被访问过的节点与边构成搜索树</p>
<ol>
<li><p>树边 在访问节点过程中走过的边</p>
</li>
<li><p>返祖边 指向祖先节点的边</p>
</li>
<li><p>横叉边 右子树指向左子树的边 图中的绿色边</p>
</li>
<li><p>前向边 指向子树中节点的边返祖边与树边必构成环，横叉边可能与树边构成环。前向边无用</p>
</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><span class="hljs-type">int</span> n, m, a, b;<br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-type">int</span> dfn[N], low[N], tot;<br><span class="hljs-comment">// dfn[x] 时间戳 节点x第一次被访问的顺序</span><br><span class="hljs-comment">// low[x] 追溯值 从节点x出发，所能访问到的最早时间戳</span><br><span class="hljs-comment">// 更新low值的意义：避免scc的节点提前出栈</span><br><span class="hljs-comment">// tot 代表首次访问该点时的时间</span><br><span class="hljs-type">int</span> stk[N], instk[N], top;<br><span class="hljs-comment">// stk 用数组模拟的栈  instk[x] 代表x点是不是仍然在栈内 top栈顶指针</span><br><span class="hljs-type">int</span> scc[N], siz[N], cnt;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 入x时，盖戳、入栈</span><br>	dfn[x] = low[x] = ++tot;<br>	stk[++top] = x, instk[x] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : e[x])<br>	&#123;<br>		<span class="hljs-keyword">if</span> (!dfn[y])<br>		&#123; <span class="hljs-comment">// 若y尚未访问</span><br>			<span class="hljs-built_in">tarjan</span>(y);<br>			low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]); <span class="hljs-comment">// 回x时更新low</span><br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instk[y])				  <span class="hljs-comment">// 若y已访问且在栈中</span><br>			low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]); <span class="hljs-comment">// 在x时更新low</span><br>	&#125;<br>	<span class="hljs-comment">// 离x时，收集SCC</span><br>	<span class="hljs-keyword">if</span> (dfn[x] == low[x])<br>	&#123; <span class="hljs-comment">// 若x是SCC的根</span><br>		<span class="hljs-type">int</span> y;<br>		++cnt;<br>		<span class="hljs-keyword">do</span><br>		&#123;<br>			y = stk[top--];<br>			instk[y] = <span class="hljs-number">0</span>;<br>			scc[y] = cnt; <span class="hljs-comment">// SCC编号 cnt就是scc的编号</span><br>			++siz[cnt];	  <span class="hljs-comment">// SCC大小</span><br>		&#125; <span class="hljs-keyword">while</span> (y != x);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">// 可能不连通</span><br>		<span class="hljs-keyword">if</span> (!dfn[i])<br>			<span class="hljs-built_in">tarjan</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="6-Tarjan-SCC-缩点"><a href="#6-Tarjan-SCC-缩点" class="headerlink" title="6.Tarjan SCC 缩点"></a>6.Tarjan SCC 缩点</h3><blockquote>
<p>通过有向有环图通过tarjan缩点之后可以变成有向无环图<br>缩点后，观察新图中点的入度、出度情况，构造答案<br>缩点后，重建拓扑图，利用拓扑图递推，找出答案</p>
<p>洛谷P2812 校园网络</p>
<p><strong>题目描述</strong></p>
<p>共有 $n$ 所学校 $(1 \leq n \leq 10000)$ 已知他们实现设计好的网络共 $m$ 条线路，为了保证高速，网络是单向的。现在请你告诉他们至少选几所学校作为共享软件的母机，能使每所学校都可以用上。再告诉他们至少要添加几条线路能使任意一所学校作为母机都可以使别的学校使用上软件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-type">int</span> dfn[N], low[N], tot;<br><span class="hljs-type">int</span> stk[N], instk[N], top;<br><span class="hljs-type">int</span> scc[N], siz[N], cnt;<br><span class="hljs-type">int</span> din[N], dout[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 入x时，盖戳、入栈</span><br>	dfn[x] = low[x] = ++tot;<br>	stk[++top] = x, instk[x] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : e[x])<br>	&#123;<br>		<span class="hljs-keyword">if</span> (!dfn[y])<br>		&#123; <span class="hljs-comment">// 若y尚未访问</span><br>			<span class="hljs-built_in">tarjan</span>(y);<br>			low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]); <span class="hljs-comment">// 回x时更新low</span><br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instk[y])				  <span class="hljs-comment">// 若y已访问且在栈中</span><br>			low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]); <span class="hljs-comment">// 在x时更新low</span><br>	&#125;<br>	<span class="hljs-comment">// 离x时，收集SCC</span><br>	<span class="hljs-keyword">if</span> (dfn[x] == low[x])<br>	&#123; <span class="hljs-comment">// 若x是SCC的根</span><br>		<span class="hljs-type">int</span> y;<br>		++cnt;<br>		<span class="hljs-keyword">do</span><br>		&#123;<br>			y = stk[top--];<br>			instk[y] = <span class="hljs-number">0</span>;<br>			scc[y] = cnt; <span class="hljs-comment">// SCC编号 cnt就是scc的编号</span><br>			++siz[cnt];	  <span class="hljs-comment">// SCC大小</span><br>		&#125; <span class="hljs-keyword">while</span> (y != x);<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n, v, ans;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; ++u)<br>		<span class="hljs-keyword">while</span> (cin &gt;&gt; v, v)<br>			e[u].<span class="hljs-built_in">push_back</span>(v);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		<span class="hljs-keyword">if</span> (!dfn[i])<br>			<span class="hljs-built_in">tarjan</span>(i);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; u++)<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e[u])<br>			<span class="hljs-keyword">if</span> (scc[u] != scc[v])<br>				dout[scc[u]]++, din[scc[v]]++;<br>	<span class="hljs-type">int</span> ans1 = <span class="hljs-number">0</span>, ans2 = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; ++i)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (!din[i])<br>			ans1++;<br>		<span class="hljs-keyword">if</span> (!dout[i])<br>			ans2++;<br>	&#125;<br>	cout &lt;&lt; ans1 &lt;&lt; endl;							  <span class="hljs-comment">// 第一问 有多少scc的入度为0</span><br>	cout &lt;&lt; (cnt == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">max</span>(ans1, ans2)) &lt;&lt; endl; <span class="hljs-comment">// 第二问 出度和入度取max 同时特判1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>洛谷P3387【模板】缩点</p>
<p><strong>题目描述</strong></p>
<p>给定一个 $n$ 个点 $m$ 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。</p>
<p>允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。</p>
<p><img src="C:\Users\LYT\Documents\cpp\File_Markdown\P3387.jpg" srcset="/img/loading.gif" lazyload alt="P3387"><br>右图圈内的点为缩点之后scc的标号，圈外的点为权值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; e[N], ne[N];<br><span class="hljs-type">int</span> dfn[N], low[N], tot;<br><span class="hljs-type">int</span> stk[N], instk[N], top;<br><span class="hljs-type">int</span> scc[N], siz[N], cnt;<br><span class="hljs-type">int</span> w[N], nw[N], dp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 入x时，盖戳、入栈</span><br>	dfn[x] = low[x] = ++tot;<br>	stk[++top] = x, instk[x] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : e[x])<br>	&#123;<br>		<span class="hljs-keyword">if</span> (!dfn[y])<br>		&#123; <span class="hljs-comment">// 若y尚未访问</span><br>			<span class="hljs-built_in">tarjan</span>(y);<br>			low[x] = <span class="hljs-built_in">min</span>(low[x], low[y]); <span class="hljs-comment">// 回x时更新low</span><br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instk[y])				  <span class="hljs-comment">// 若y已访问且在栈中</span><br>			low[x] = <span class="hljs-built_in">min</span>(low[x], dfn[y]); <span class="hljs-comment">// 在x时更新low</span><br>	&#125;<br>	<span class="hljs-comment">// 离x时，收集SCC</span><br>	<span class="hljs-keyword">if</span> (dfn[x] == low[x])<br>	&#123; <span class="hljs-comment">// 若x是SCC的根</span><br>		<span class="hljs-type">int</span> y;<br>		++cnt;<br>		<span class="hljs-keyword">do</span><br>		&#123;<br>			y = stk[top--];<br>			instk[y] = <span class="hljs-number">0</span>;<br>			scc[y] = cnt; <span class="hljs-comment">// SCC编号 cnt就是scc的编号</span><br>			++siz[cnt];	  <span class="hljs-comment">// SCC大小</span><br>		&#125; <span class="hljs-keyword">while</span> (y != x);<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n, m;<br>	cin &gt;&gt; n &gt;&gt; m;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		cin &gt;&gt; w[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> u, v;<br>		cin &gt;&gt; u &gt;&gt; v;<br>		e[u].<span class="hljs-built_in">push_back</span>(v);<br>	&#125;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		<span class="hljs-keyword">if</span> (!dfn[i])<br>			<span class="hljs-built_in">tarjan</span>(i);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; ++u)<br>	&#123;<br>		nw[scc[u]] += w[u]; <span class="hljs-comment">// 新点的权值</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e[u])<br>			<span class="hljs-keyword">if</span> (scc[u] != scc[v])<br>				ne[scc[u]].<span class="hljs-built_in">push_back</span>(scc[v]);<br>	&#125; <span class="hljs-comment">// 缩点后建拓扑图</span><br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = cnt; u; --u)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (dp[u] == <span class="hljs-number">0</span>) <span class="hljs-comment">// 起点</span><br>			dp[u] = nw[u];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : ne[u])<br>			dp[v] = <span class="hljs-built_in">max</span>(dp[v], dp[u] + nw[v]);<br><br>	&#125; <span class="hljs-comment">// 在拓扑上做逆序dp</span><br><br>	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; ++i)<br>		ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>	cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<h3 id="7-Tarjan-割点"><a href="#7-Tarjan-割点" class="headerlink" title="7.Tarjan  割点"></a>7.Tarjan  割点</h3><blockquote>
<p>割点判定法则：<code>low[y] &gt;= dfn[x]</code> 。非根节点需要找到一棵子树，根节点需要找到两棵子树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br>set&lt;<span class="hljs-type">int</span>&gt; ans;<br><span class="hljs-type">int</span> n, m, root;<br><span class="hljs-type">int</span> dfn[N], low[N], tot;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>	dfn[u] = low[u] = ++tot;<br>	<span class="hljs-type">int</span> child = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e[u])<br>	&#123;<br>		<span class="hljs-keyword">if</span> (!dfn[v])<br>		&#123;<br>			<span class="hljs-built_in">tarjan</span>(v);<br>			low[u] = <span class="hljs-built_in">min</span>(low[u], low[v]);<br>			<span class="hljs-keyword">if</span> (low[v] &gt;= dfn[u])<br>			&#123;<br>				child++;<br>				<span class="hljs-keyword">if</span> (u != root || child &gt; <span class="hljs-number">1</span>)<br>					ans.<span class="hljs-built_in">insert</span>(u);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>			low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[v]);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<h3 id="8-最近公共祖先-LCA"><a href="#8-最近公共祖先-LCA" class="headerlink" title="8.最近公共祖先(LCA)"></a>8.最近公共祖先(LCA)</h3><blockquote>
<p>重儿子：父结点的所有的所有儿子中子树结点数目中最多的结点<br>轻儿子：父结点中除重儿子以外的儿子<br>重边：父结点和重儿子连成的边<br>轻边：父结点和轻儿子连成的边<br>重链：有多条重边连接而成的路径<br>性质：任意一条路径被切分成不超过 $logn$ 条链</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//fa[u]:存u的父结点,dep[u]:存u的深度,son[u]:存u的重儿子,</span><br><span class="hljs-comment">//sz[u]:存以u为根的子树的结点数,top[u]:存u所在重链的顶点</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-type">int</span> fa[N], son[N], dep[N], siz[N], top[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> f)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 搞fa,son,dep</span><br>	fa[u] = f;<br>	siz[u] = <span class="hljs-number">1</span>;<br>	dep[u] = dep[f] + <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e[u])<br>	&#123;<br>		<span class="hljs-keyword">if</span> (v == f)<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">dfs1</span>(v, u);<br>		siz[u] += siz[v];<br>		<span class="hljs-keyword">if</span> (siz[son[u]] &lt; siz[v])<br>			son[u] = v;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;				<span class="hljs-comment">// 搞top</span><br>	top[u] = t; <span class="hljs-comment">// 记录链头</span><br>	<span class="hljs-keyword">if</span> (!son[u])<br>		<span class="hljs-keyword">return</span>;		 <span class="hljs-comment">// 无重儿子</span><br>	<span class="hljs-built_in">dfs2</span>(son[u], t); <span class="hljs-comment">// 搜重儿子</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e[u])<br>	&#123;<br>		<span class="hljs-keyword">if</span> (v == fa[u] || v == son[u])<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">dfs2</span>(v, v); <span class="hljs-comment">// 搜轻儿子</span><br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">while</span> (top[u] != top[v])<br>	&#123;<br>		<span class="hljs-keyword">if</span> (dep[top[u]] &lt; dep[top[v]])<br>			<span class="hljs-built_in">swap</span>(u, v);<br>		u = fa[top[u]];<br>	&#125;<br>	<span class="hljs-keyword">return</span> dep[u] &lt; dep[v] ? u : v;<br>&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<h3 id="9-分层图"><a href="#9-分层图" class="headerlink" title="9.分层图"></a>9.分层图</h3><blockquote>
<p>怎么用分层图<br>给定N个点，M条边，允许对K条边进行改变(对权值进行一些改变，如把花费&#x2F;2，变为0之类的)，求最短路的问题对k条边进行改变,就建k+1层图 每层之间的边都是有向边，本质上是一种建图技巧。</p>
<p>洛谷 P4568 飞行路线<br>题目描述<br>Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。Alice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？</p>
<p>输入格式<br>第一行三个整数 $n,m,k$，分别表示城市数，航线数和免费乘坐次数,接下来一行两个整数 $s,t$，分别表示他们出行的起点城市编号和终点城市编号。接下来 $m$ 行，每行三个整数 $a,b,c$，表示存在一种航线，能从城市 $a$ 到达城市 $b$，或从城市 $b$ 到达城市 $a$ ，价格为 $c$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>	<span class="hljs-type">int</span> x, w;							<span class="hljs-comment">// x表示出点，w表示权值</span><br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node &amp;v) <span class="hljs-type">const</span> <span class="hljs-comment">// 按照w小的优先</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> w == v.w ? x &lt; v.x : w &gt; v.w;<br>	&#125;<br>&#125;;<br>vector&lt;node&gt; e[N];<br><span class="hljs-type">int</span> d[N], n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">memset</span>(d, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(d));<br>	d[st] = <span class="hljs-number">0</span>;	   <span class="hljs-comment">// 初始化起点</span><br>	bitset&lt;N&gt; vis; <span class="hljs-comment">// 表示已经拓展过</span><br>	priority_queue&lt;node&gt; pq;<br>	pq.<span class="hljs-built_in">push</span>(&#123;st, d[st]&#125;); <span class="hljs-comment">// 把起点作为拓展点</span><br><br>	<span class="hljs-keyword">while</span> (pq.<span class="hljs-built_in">size</span>())<br>	&#123;<br>		<span class="hljs-type">int</span> t = pq.<span class="hljs-built_in">top</span>().x;<br>		pq.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span> (vis[t])<br>			<span class="hljs-keyword">continue</span>;<br>		vis[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 取出的t点已经得到了最短距离d[x]</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[y, w] : e[t])<br>		&#123;<br>			<span class="hljs-keyword">if</span> (!vis[y] &amp;&amp; d[y] &gt; d[t] + w) <span class="hljs-comment">// 如果vis[y] 说明y已经得到最短距离 无需更新</span><br>			&#123;<br>				d[y] = d[t] + w;<br>				pq.<span class="hljs-built_in">push</span>(&#123;y, d[y]&#125;);<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n, m, k, ans = inf;<br>	<span class="hljs-type">int</span> st, ed;<br>	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>	cin &gt;&gt; st &gt;&gt; ed;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> u, v, w;<br>		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>		e[u].<span class="hljs-built_in">push_back</span>(&#123;v, w&#125;);<br>		e[v].<span class="hljs-built_in">push_back</span>(&#123;u, w&#125;);<br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++j)<br>		&#123;<br><br>			e[n * j + u].<span class="hljs-built_in">push_back</span>(&#123;n * (j + <span class="hljs-number">1</span>) + v, <span class="hljs-number">0</span>&#125;);<br>			e[n * j + v].<span class="hljs-built_in">push_back</span>(&#123;n * (j + <span class="hljs-number">1</span>) + u, <span class="hljs-number">0</span>&#125;);<br>			e[n * (j + <span class="hljs-number">1</span>) + u].<span class="hljs-built_in">push_back</span>(&#123;n * (j + <span class="hljs-number">1</span>) + v, w&#125;);<br>			e[n * (j + <span class="hljs-number">1</span>) + v].<span class="hljs-built_in">push_back</span>(&#123;n * (j + <span class="hljs-number">1</span>) + u, w&#125;);<br>		&#125;<br>		e[n * k + u].<span class="hljs-built_in">push_back</span>(&#123;n * k + v, w&#125;);<br>		e[n * k + v].<span class="hljs-built_in">push_back</span>(&#123;n * k + u, w&#125;);<br>	&#125;<br><br>	<span class="hljs-built_in">dijkstra</span>(st);<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; ++i)<br>	&#123;<br>		ans = <span class="hljs-built_in">min</span>(ans, d[ed + i * n]);<br>	&#125;<br>	cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h2 id="三、动态规划"><a href="#三、动态规划" class="headerlink" title="三、动态规划"></a>三、动态规划</h2><h3 id="1-背包dp"><a href="#1-背包dp" class="headerlink" title="1.背包dp"></a>1.背包dp</h3><blockquote>
<ul>
<li><p>01背包</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = v; j &gt;= <span class="hljs-number">1</span>; --j)倒序<br>		&#123;<br>			<span class="hljs-keyword">if</span> (j &lt; w[i])<br>				dp[j] = dp[j];<br>			<span class="hljs-keyword">else</span><br>				dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + w[i]);<br>				<span class="hljs-comment">//dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i]] + w[i]);</span><br>		&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>完全背包（选取物品数量不限制）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= v; ++j)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (j &lt; w[i])<br>				dp[j] = dp[j];<br>			<span class="hljs-keyword">else</span><br>				dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + w[i]);<br>				<span class="hljs-comment">//dp[i][j] = max(dp[i][j], dp[i][j - w[i]] + w[i]);</span><br>		&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>分组背包</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<span class="hljs-comment">//枚举组数</span><br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j)<span class="hljs-comment">//背包容量</span><br>		&#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= g[i]; ++k)<span class="hljs-comment">//抉择选哪一个物品</span><br>			&#123;<br>				<span class="hljs-keyword">if</span> (j &gt;= w[i][k])<br>					dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - w[i][k]] + v[i][k]);<br>			&#125;<br>		&#125;<br>	&#125;<br>	cout &lt;&lt; dp[s.<span class="hljs-built_in">size</span>()][m];<br></code></pre></td></tr></table></figure>
</li>
<li><p>多维费用背包</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = M; j &gt;= m[i]; --j)<br>		&#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = T; k &gt;= t[i]; --k)<br>			&#123;<br>				dp[j][k] = <span class="hljs-built_in">max</span>(dp[j][k], dp[j - m[i]][k - t[i]] + <span class="hljs-number">1</span>);<br>			&#125;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>01背包 求方案数  不超背包容量的方案数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> f[N], c[N];<br><span class="hljs-comment">// f[i]表示背包容量为i时最优选法的总价值</span><br><span class="hljs-comment">// c[i]表示背包容量为i时最优选法的方案数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n, m, v, w;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++)<br>		c[i] = <span class="hljs-number">1</span>;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123; <span class="hljs-comment">// 枚举物品</span><br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;v, &amp;w);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v; j--)<br>		&#123; <span class="hljs-comment">// 枚举体积</span><br>			<span class="hljs-keyword">if</span> (f[j - v] + w &gt; f[j])<br>			&#123; <span class="hljs-comment">// 装新物品总价值更大</span><br>				f[j] = f[j - v] + w;<br>				c[j] = c[j - v];<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f[j - v] + w == f[j]) <span class="hljs-comment">// 装新物品总价值相等</span><br>				c[j] = (c[j] + c[j - v]) % mod;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c[m]);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>恰好装满的容量数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> f[N], c[N];<br><span class="hljs-comment">// f[i]表示背包容量为i时最优选法的总价值</span><br><span class="hljs-comment">// c[i]表示背包容量为i时最优选法的方案数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n, m, v, w;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>                                                                                                                                                                                                               <br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>		f[i] = <span class="hljs-number">-1000</span>;<br>	f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, c[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>                                                                                                                                                                                                               <br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123; <span class="hljs-comment">// 枚举物品</span><br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;v, &amp;w);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v; j--)<br>		&#123; <span class="hljs-comment">// 枚举体积</span><br>			<span class="hljs-keyword">if</span> (f[j - v] + w &gt; f[j])<br>			&#123; <span class="hljs-comment">// 装新物品总价值更大</span><br>				f[j] = f[j - v] + w;<br>				c[j] = c[j - v];<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f[j - v] + w == f[j]) <span class="hljs-comment">// 装新物品总价值相等</span><br>				c[j] = (c[j] + c[j - v]) % mod;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c[m]);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h3 id="2-树形dp"><a href="#2-树形dp" class="headerlink" title="2.树形dp"></a>2.树形dp</h3><blockquote>
<p><strong>实现形式</strong><br>树形$dp$的主要实现形式是$dfs$，在$dfs$中$dp$，主要的实现形式是$dp[i][j][0&#x2F;1]$，$i$是以$i$为根的子树，$j$是表示在以$i$为根的子树中选择$j$个子节点，$0$表示这个节点不选，$1$表示选择这个节点。有的时候$j$或$0&#x2F;1$这一维可以压掉</p>
<p><strong>基本的dp方程</strong></p>
<p>选择节点类<br>$$<br>\left{<br>\begin{array}{l}<br>dp[i][0]&#x3D;dp[j][1]\<br>dp[i][1]&#x3D;\max&#x2F;\min(dp[j][0],dp[j][1])\<br>\end{array}<br>\right.<br>$$<br>树形背包类<br>$$<br>\left{<br>\begin{array}{l}<br>dp[v][k]&#x3D;dp[u][k]+val\<br>dp[u][k]&#x3D;max(dp[u][k],dp[v][k-1])\<br>\end{array}<br>\right.<br>$$</p>
<p>洛谷P1352 没有上司的舞会</p>
<p>题目描述</p>
<p>某大学有 $n$ 个职员，编号为 $1\ldots n$。<br>他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。<br>现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。<br>所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p>
<p>输入格式</p>
<p>输入的第一行是一个整数 $n$。<br>第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。<br>第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。</p>
<p>$f[x][0]$ 表示以 $x$ 为根的子树,且 $x$ 不参加舞会的最大快乐值, $f[x][1]$ 表示以 $x$ 为根的子树，且 $x$ 参加了舞会的最大快乐值,则 $f[x][0]&#x3D;\sum{max(f[y][0],f[y][1])}$ ( $y$ 是 $x$ 的儿子), $f[x][1]&#x3D;\sum{f[y][0]}+r[x]$ ( $y$ 是 $x$ 的儿子),先找到唯一的树根 $root$ 则 $ans&#x3D;max(f[root][0],f[root][1])$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> r[N], d[N], dp[N][<span class="hljs-number">3</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>	dp[x][<span class="hljs-number">1</span>] = r[x];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : e[x])<br>	&#123;<br>		<span class="hljs-built_in">dfs</span>(i);<br>		dp[x][<span class="hljs-number">1</span>] += dp[i][<span class="hljs-number">0</span>];<br>		dp[x][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(dp[i][<span class="hljs-number">0</span>], dp[i][<span class="hljs-number">1</span>]);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		cin &gt;&gt; r[i];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> u, v;<br>		cin &gt;&gt; u &gt;&gt; v;<br>		e[v].<span class="hljs-built_in">push_back</span>(u);<br>		d[u]++;<br>	&#125;<br>	<span class="hljs-type">int</span> st;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		<span class="hljs-keyword">if</span> (!d[i])<br>		&#123;<br>			st = i;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br><br>	<span class="hljs-built_in">dfs</span>(st);<br><br>	cout &lt;&lt; <span class="hljs-built_in">max</span>(dp[st][<span class="hljs-number">0</span>], dp[st][<span class="hljs-number">1</span>]) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>洛谷P2899  Cell Phone Network G</p>
<p>Farmer John 想让他的所有牛用上手机以便相互交流。他需要建立几座信号塔在 $N$ 块草地中。已知与信号塔相邻的草地能收到信号。给你 $N-1$ 个草地 $(A,B)$ 的相邻关系，问：最少需要建多少个信号塔能实现所有草地都有信号。</p>
<p><strong>点覆盖边</strong>只涉及父子关系，<strong>点覆盖点</strong>的状态涉及祖宗三代</p>
<p><img src="C:\Users\LYT\Documents\cpp\File_Markdown\P2889.jpg" srcset="/img/loading.gif" lazyload alt="P2889"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dp[N][<span class="hljs-number">3</span>];<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">0 u被自己覆盖的最小花费(u上放天线)</span><br><span class="hljs-comment">1 u被儿子覆盖的最小花费(u上没放天线)</span><br><span class="hljs-comment">2 u被父亲覆盖的最小花费(u上没放天线)</span><br><span class="hljs-comment">*/</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>	dp[u][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u])<br>	&#123;<br>		<span class="hljs-keyword">if</span> (v == fa)<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">dfs</span>(v, u);<br>		dp[u][<span class="hljs-number">0</span>] += <span class="hljs-built_in">min</span>(&#123;dp[v][<span class="hljs-number">0</span>], dp[v][<span class="hljs-number">1</span>], dp[v][<span class="hljs-number">2</span>]&#125;);<br>		dp[u][<span class="hljs-number">2</span>] += <span class="hljs-built_in">min</span>(dp[v][<span class="hljs-number">0</span>], dp[v][<span class="hljs-number">1</span>]);<br>		<span class="hljs-keyword">if</span> (dp[t][<span class="hljs-number">0</span>] - <span class="hljs-built_in">min</span>(dp[t][<span class="hljs-number">0</span>], dp[t][<span class="hljs-number">1</span>]) &gt; dp[v][<span class="hljs-number">0</span>] - <span class="hljs-built_in">min</span>(dp[v][<span class="hljs-number">0</span>], dp[v][<span class="hljs-number">1</span>]))<br>			t = v;<br>	&#125;<br>	dp[u][<span class="hljs-number">1</span>] = dp[t][<span class="hljs-number">0</span>]; <span class="hljs-comment">// t为最优儿子</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u])<br>	&#123;<br>		<span class="hljs-keyword">if</span> (v == fa || v == t)<br>			<span class="hljs-keyword">continue</span>;<br>		dp[u][<span class="hljs-number">1</span>] += <span class="hljs-built_in">min</span>(dp[v][<span class="hljs-number">0</span>], dp[v][<span class="hljs-number">1</span>]);<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> u, v;<br>		cin &gt;&gt; u &gt;&gt; v;<br>		e[u].<span class="hljs-built_in">push_back</span>(v);<br>		e[v].<span class="hljs-built_in">push_back</span>(u);<br>	&#125;<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = inf;<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>	cout &lt;&lt; <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>洛谷P2014 [CTSC1997] 选课（树上背包）</p>
<p><strong>题目描述</strong><br>在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？</p>
<p><strong>输入格式</strong></p>
<p>第一行有两个整数 $N$ , $M$ 用空格隔开。( $1 \leq N \leq 300$ , $1 \leq M \leq 300$ )接下来的 $N$ 行,第 $I+1$ 行包含两个整数 $k_i $和 $s_i$, $k_i$ 表示第I门课的直接先修课，$s_i$ 表示第I门课的学分。若 $k_i&#x3D;0$ 表示没有直接先修课（$1 \leq {k_i} \leq N$ , $1 \leq {s_i} \leq 20$）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// dp[i][j]表示以i为子树的根，容量不超过j时所获得的最大价值</span><br><span class="hljs-comment">// 该转移方程实际上是一个分组背包</span><br><span class="hljs-type">int</span> dp[N][N], value[N], siz[N];<br><span class="hljs-comment">//int weight[N];</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>	siz[u] = <span class="hljs-number">1</span>; <span class="hljs-comment">// dp[u][1]=value[u];</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>		dp[u][i] = value[u];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e[u])<br>	&#123;<br>		<span class="hljs-built_in">dfs</span>(v);<br>		siz[u] += siz[v];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-built_in">min</span>(m, siz[u]); j &gt;= <span class="hljs-number">1</span>; --j)<span class="hljs-comment">//for(int i=m;m&gt;=weight[u];j--)</span><br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= j - <span class="hljs-number">1</span>; ++k)<span class="hljs-comment">//for(int k=0;k&lt;=j-weight[u];k++)</span><br>				dp[u][j] = <span class="hljs-built_in">max</span>(dp[u][j], dp[u][j - k] + dp[v][k]);<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>	cin &gt;&gt; n &gt;&gt; m;<br>	m++;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> k;<br>		cin &gt;&gt; k &gt;&gt; value[i];<br>		e[k].<span class="hljs-built_in">push_back</span>(i);<br>	&#125;<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>	cout &lt;&lt; dp[<span class="hljs-number">0</span>][m] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<h3 id="3-换根dp"><a href="#3-换根dp" class="headerlink" title="3.换根dp"></a>3.换根dp</h3><blockquote>
<p>是树形dp的一种，其相比于一般的树形DP具有以下特点：</p>
<ul>
<li>以树上的不同点作为根，其解不同。</li>
<li>故为求解答案，不能单求某点的信息，需要求解每个节点的信息。</li>
<li>故无法通过一次搜索完成答案的求解，因为一次搜索只能得到一个节点的答案。</li>
</ul>
<p>[ABC348E] Minimize Sum of Distances</p>
<p><strong>题目描述</strong></p>
<p>给出一棵 $n$ 个点的树，以及每个点的权值 $C_i$。<br>设 $d(u,v)$ 表示树上 $u,v$ 两点之间的距离，设 $f(x)&#x3D;\sum\limits_{i&#x3D;1}^n C_i\times d(x,i)$，求 $\min\limits_{1\le v\le N}f(v)$。</p>
<p>大概就是先遍历求出以1为根的 $dp_1$ ，然后根据递推式再去推以其他点为根的 $dp_i$ ，最后取最小值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-type">int</span> c[N], dp[N], tot, sum[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> dep)</span></span><br><span class="hljs-function"></span>&#123;<br>	dp[<span class="hljs-number">1</span>] += c[u] * dep;<br>	sum[u]=c[u];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e[u])<br>	&#123;<br>		<span class="hljs-keyword">if</span> (v == fa)<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-built_in">dfs1</span>(v, u, dep + <span class="hljs-number">1</span>);<br>		sum[u] += sum[v];<br>	&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>	<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e[u])<br>	&#123;<br>		<span class="hljs-keyword">if</span> (v == fa)<br>			<span class="hljs-keyword">continue</span>;<br>		dp[v] = dp[u] - sum[v] * <span class="hljs-number">2</span> + tot;<br>		<span class="hljs-built_in">dfs2</span>(v, u);<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> u, v;<br>		cin &gt;&gt; u &gt;&gt; v;<br>		e[u].<span class="hljs-built_in">push_back</span>(v);<br>		e[v].<span class="hljs-built_in">push_back</span>(u);<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>	&#123;<br>		cin &gt;&gt; c[i];<br>		tot += c[i];<br>	&#125;<br><br>	<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-type">int</span> ans = dp[<span class="hljs-number">1</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		ans = <span class="hljs-built_in">min</span>(ans, dp[i]);<br>	cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<h3 id="4-状压dp"><a href="#4-状压dp" class="headerlink" title="4.状压dp"></a>4.状压dp</h3><blockquote>
<p>没有固定的模板，状态是二进制压缩后的</p>
<p>洛谷P1896 互不侵犯</p>
<p>题目描述</p>
<p>在 $N \times N$ 的棋盘里面放 $K$ 个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共 $8$ 个格子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dp[<span class="hljs-number">11</span>][<span class="hljs-number">100</span>][<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>];<span class="hljs-comment">//dp[i,j,a]表示前i行已经放了j个国王，第a个状态时的方案数</span><br>vector&lt;<span class="hljs-type">int</span>&gt; s, <span class="hljs-built_in">num</span>(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">12</span>);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n, k;<br>	cin &gt;&gt; n &gt;&gt; k;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++i)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (!(i &amp; i &gt;&gt; <span class="hljs-number">1</span>))<br>		&#123;<br>			s.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">//一行的合法状态集</span><br>			bitset&lt;16&gt; b = i;<br>			num[i] = b.<span class="hljs-built_in">count</span>();<span class="hljs-comment">//每个合法状态包含的国王数</span><br>		&#125;<br>	&#125;<br>	dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; ++i)<span class="hljs-comment">//枚举行</span><br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= k; ++j)<span class="hljs-comment">//枚举国王数</span><br>		&#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; s.<span class="hljs-built_in">size</span>(); ++a)<span class="hljs-comment">//枚举第i行的合法状态</span><br>			&#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">0</span>; b &lt; s.<span class="hljs-built_in">size</span>(); ++b)<span class="hljs-comment">//枚举第i-1行的合法状态</span><br>				&#123;<br>					<span class="hljs-type">int</span> c = num[s[a]];<br>					<span class="hljs-keyword">if</span> (j &gt;= c &amp;&amp; !(s[b] &amp; s[a]) &amp;&amp; !(s[b] &amp; (s[a] &lt;&lt; <span class="hljs-number">1</span>)) &amp;&amp; !(s[b] &amp; (s[a] &gt;&gt; <span class="hljs-number">1</span>)))<br>					&#123;<br>                        <span class="hljs-comment">//不存在同列的1 不存斜对角的1</span><br>						dp[i][j][a] += dp[i - <span class="hljs-number">1</span>][j - c][b];<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	cout &lt;&lt; dp[n + <span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>] &lt;&lt; endl;<span class="hljs-comment">//第n+1行不放国王的方案数</span><br>&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<h2 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h2><h3 id="1-KMP算法"><a href="#1-KMP算法" class="headerlink" title="1.KMP算法"></a>1.KMP算法</h3><blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// next[i]表示模式串中P[1,i]中相等前缀和后缀的最长长度</span><br><span class="hljs-comment">// ne[5]=2  a a b a a 相等的前缀和后缀都是 a a 因此 =2</span><br><span class="hljs-comment">// P 是模式串 S 是我们要找的主串 从主串中找</span><br><span class="hljs-comment">// n 是模式串的长度 m是主串的长度</span><br><span class="hljs-comment">// 计算next函数</span><br><span class="hljs-comment">// 字符串下标从1开始</span><br>ne[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>&#123;<br>	<span class="hljs-keyword">while</span> (j &amp;&amp; P[i] != P[j + <span class="hljs-number">1</span>])<br>		j = ne[j];<br>	<span class="hljs-keyword">if</span> (P[i] == P[j + <span class="hljs-number">1</span>])<br>		j++;<br>	ne[i] = j;<br>&#125;<br><span class="hljs-comment">// KMP匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i++)<br>&#123;<br>	<span class="hljs-keyword">while</span> (j &amp;&amp; S[i] != P[j + <span class="hljs-number">1</span>])<br>		j = ne[j];<br>	<span class="hljs-keyword">if</span> (S[i] == P[j + <span class="hljs-number">1</span>])<br>		j++;<br>	<span class="hljs-keyword">if</span> (j == n)<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i - n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 模式串与主串的字串匹配 输出字串的开头数组下标</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="2-字典树"><a href="#2-字典树" class="headerlink" title="2.字典树"></a>2.字典树</h3><blockquote>
<p>是一种能够快速插入和查询字符串的多叉树结构，根节点编号为0，其他节点用来标识路径，还可以标记单词插入的次数，边表示字符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-type">int</span> ch[N][<span class="hljs-number">26</span>]; <span class="hljs-comment">// 儿子数组 ch[p][j] 从节点p沿着j这条边走到的子节点 a-z 0-25</span><br>&gt;<span class="hljs-type">int</span> cnt[N];	   <span class="hljs-comment">// 存储以p结尾的单词的插入次数</span><br>&gt;<span class="hljs-type">int</span> idx;	   <span class="hljs-comment">// 用来给节点编号</span><br>&gt;<span class="hljs-type">char</span> s[N];<br><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br><span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; s[i]; ++i)<br>&#123;<br>	<span class="hljs-type">int</span> j = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 字符映射</span><br>	<span class="hljs-keyword">if</span> (!ch[p][j])<br>		ch[p][j] = ++idx;<br>	p = ch[p][j];<br>&#125;<br>cnt[p]++;<br>&gt;&#125;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function">&gt;</span>&#123; <span class="hljs-comment">// 返回插入次数</span><br><span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; s[i]; ++i)<br>&#123;<br>	<span class="hljs-type">int</span> j = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 字符映射</span><br>	<span class="hljs-keyword">if</span> (!ch[p][j])<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	p = ch[p][j];<br>&#125;    <br><span class="hljs-keyword">return</span> cnt[p];<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="3-AC自动机"><a href="#3-AC自动机" class="headerlink" title="3.AC自动机"></a>3.AC自动机</h3><blockquote>
<p>是多模式匹配算法 给定n个模式串和一个主串，查找有多少个模式串在主串中出现过<br><code>ne[v]</code> 存节点v回跳边的终点 回跳边指向父节点的回跳边所指节点的儿子</p>
<p> 回跳边所指节点一定是当前节点的最长后缀(初始都是0)<br> <code>ch[u][i]</code> 存节点u的树边的终点 （跟字典树ch数组意义一样）， 存节点u的转移边的终点 转移边指向当前节点的回跳边所指节点的儿子，转移边所指节点一定是当前节点的最短路，用bfs构造ac自动机</p>
<ol>
<li>若儿子存在，则父亲帮儿子建回跳边，并把儿子入队</li>
<li>若儿子不存在，则父亲自建转移边</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ne[N];<br><span class="hljs-type">int</span> ch[N][<span class="hljs-number">26</span>]; <span class="hljs-comment">// 儿子数组 ch[p][j] 从节点p沿着j这条边走到的子节点 a-z 0-25</span><br><span class="hljs-type">int</span> cnt[N];	   <span class="hljs-comment">// 存储以p结尾的单词的插入次数</span><br><span class="hljs-type">int</span> idx;	   <span class="hljs-comment">// 用来给节点编号</span><br><span class="hljs-type">char</span> s[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 建AC自动机</span><br>	queue&lt;<span class="hljs-type">int</span>&gt; q;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>		<span class="hljs-keyword">if</span> (ch[<span class="hljs-number">0</span>][i])<br>			q.<span class="hljs-built_in">push</span>(ch[<span class="hljs-number">0</span>][i]);<br>	<span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>	&#123;<br>		<span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>		q.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>		&#123;<br>			<span class="hljs-type">int</span> v = ch[u][i];<br>			<span class="hljs-keyword">if</span> (v)<br>				ne[v] = ch[ne[u]][i], q.<span class="hljs-built_in">push</span>(v);<br>			<span class="hljs-keyword">else</span><br>				ch[u][i] = ch[ne[u]][i];<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span> <span class="hljs-comment">// 建字典树</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; s[i]; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> j = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 字符映射</span><br>		<span class="hljs-keyword">if</span> (!ch[p][j])<br>			ch[p][j] = ++idx;<br>		p = ch[p][j];<br>	&#125;<br>	cnt[p]++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query1</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 返回插入次数</span><br>	<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; s[i]; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> j = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 字符映射</span><br>		<span class="hljs-keyword">if</span> (!ch[p][j])<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		p = ch[p][j];<br>	&#125;<br>	<span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query2</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span><span class="hljs-comment">//查找单词出现的次数</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>; s[k]; k++)<br>	&#123;<br>		i = ch[i][s[k] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &amp;&amp; ~cnt[j]; j = ne[j])<br>			ans += cnt[j], cnt[j] = <span class="hljs-number">-1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="4-随机生成模底-字符串哈希（例题）"><a href="#4-随机生成模底-字符串哈希（例题）" class="headerlink" title="4.随机生成模底 字符串哈希（例题）"></a>4.随机生成模底 字符串哈希（例题）</h3><blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)<br>		&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isprime</span>(n))<br>	&#123;<br>		n++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> n;<br>&#125;<br><span class="hljs-keyword">using</span> Hash = std::array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">2</span>&gt;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>	<span class="hljs-function">std::mt19937 <span class="hljs-title">rng</span><span class="hljs-params">(std::chrono::steady_clock::now().time_since_epoch().count())</span></span>;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-built_in">findPrime</span>(<span class="hljs-built_in">rng</span>() % <span class="hljs-number">900000000</span> + <span class="hljs-number">100000000</span>);<br>	std::string s, x;<br>	std::cin &gt;&gt; s &gt;&gt; x;<br>	<span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>	<span class="hljs-type">int</span> m = x.<span class="hljs-built_in">length</span>();<br>	<span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">h</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>	&#123;<br>		h[i + <span class="hljs-number">1</span>] = (<span class="hljs-number">10LL</span> * h[i] + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) % P;<br>	&#125;<br>	p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>	&#123;<br>		p[i + <span class="hljs-number">1</span>] = <span class="hljs-number">10LL</span> * p[i] % P;<br>	&#125;<br>	<span class="hljs-keyword">auto</span> get = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)<br>	&#123; <span class="hljs-built_in">return</span> (h[r] + <span class="hljs-number">1LL</span> * (P - h[l]) * p[r - l]) % P; &#125;;<br>	<span class="hljs-type">int</span> px = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : x)<br>	&#123;<br>		px = (<span class="hljs-number">10LL</span> * px + c - <span class="hljs-string">&#x27;0&#x27;</span>) % P;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n - <span class="hljs-number">2</span> * (m - <span class="hljs-number">1</span>); i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span> ((<span class="hljs-built_in">get</span>(i, i + m - <span class="hljs-number">1</span>) + <span class="hljs-built_in">get</span>(i + m - <span class="hljs-number">1</span>, i + <span class="hljs-number">2</span> * m - <span class="hljs-number">2</span>)) % P == px)<br>		&#123;<br>			std::cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i + m - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>			std::cout &lt;&lt; i + m &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i + <span class="hljs-number">2</span> * m - <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>	z[<span class="hljs-number">0</span>] = m;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">-1</span>; i &lt; m; i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (j != <span class="hljs-number">-1</span>)<br>		&#123;<br>			z[i] = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, std::<span class="hljs-built_in">min</span>(j + z[j] - i, z[i - j]));<br>		&#125;<br>		<span class="hljs-keyword">while</span> (z[i] + i &lt; m &amp;&amp; x[z[i]] == x[z[i] + i])<br>		&#123;<br>			z[i]++;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || i + z[i] &gt; j + z[j])<br>		&#123;<br>			j = i;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>; i &lt; n; i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (j != <span class="hljs-number">-1</span>)<br>		&#123;<br>			f[i] = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, std::<span class="hljs-built_in">min</span>(j + f[j] - i, z[i - j]));<br>		&#125;<br>		<span class="hljs-keyword">while</span> (f[i] + i &lt; n &amp;&amp; f[i] &lt; m &amp;&amp; x[f[i]] == s[f[i] + i])<br>		&#123;<br>			f[i]++;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || i + f[i] &gt; j + f[j])<br>		&#123;<br>			j = i;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + m &lt;= n; i++)<br>	&#123;<br>		<span class="hljs-type">int</span> l = std::<span class="hljs-built_in">min</span>(m, f[i]);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j : &#123;m - l, m - l - <span class="hljs-number">1</span>&#125;)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (j &lt;= <span class="hljs-number">0</span>)<br>			&#123;<br>				<span class="hljs-keyword">continue</span>;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (j &lt;= i &amp;&amp; (<span class="hljs-built_in">get</span>(i - j, i) + <span class="hljs-built_in">get</span>(i, i + m)) % P == px)<br>			&#123;<br>				std::cout &lt;&lt; i - j + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>				std::cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i + m &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (i + m + j &lt;= n &amp;&amp; (<span class="hljs-built_in">get</span>(i, i + m) + <span class="hljs-built_in">get</span>(i + m, i + m + j)) % P == px)<br>			&#123;<br>				std::cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i + m &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>				std::cout &lt;&lt; i + m + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i + m + j &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<h2 id="五、数学"><a href="#五、数学" class="headerlink" title="五、数学"></a>五、数学</h2><h3 id="1-快速幂"><a href="#1-快速幂" class="headerlink" title="1.快速幂"></a>1.快速幂</h3><blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_power</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span> (n)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>)<br>			ans = ans * a % mod;<br>		a = a * a % mod;<br>		n &gt;&gt;= <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans % mod;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="2-质因数的分解"><a href="#2-质因数的分解" class="headerlink" title="2.质因数的分解"></a>2.质因数的分解</h3><blockquote>
<p> 试除法 算数基本定理 每个正整数都能够唯一的表示它的质因数的乘积<br>$$<br>n&#x3D;p_1^{a_1}p_2^{a_2}…(p为质数)<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10001</span>]; <span class="hljs-comment">// 质因子的个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decompose</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 分解质因数</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; i++)<br>		<span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)<br>			a[i]++, x /= i;<br>	<span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>)<br>		a[x]++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>		<span class="hljs-built_in">decompose</span>(i);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>		<span class="hljs-keyword">if</span> (a[i])<br>			cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; a[i] &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="3-求质数"><a href="#3-求质数" class="headerlink" title="3.求质数"></a>3.求质数</h3><blockquote>
<ul>
<li><p>线性筛法求质数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> vis[N];	 <span class="hljs-comment">// 划掉合数</span><br><span class="hljs-type">int</span> prim[N]; <span class="hljs-comment">// 记录质数</span><br><span class="hljs-type">int</span> cnt;	 <span class="hljs-comment">// 质数个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_prim</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 线性筛法</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (!vis[i])<br>			prim[++cnt] = i;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; <span class="hljs-number">1ll</span> * i * prim[j] &lt;= n; j++)<br>		&#123;<br>			vis[i * prim[j]] = <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">if</span> (i % prim[j] == <span class="hljs-number">0</span>)<br>				<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>miller-robin素性测试</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt; check = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">37</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">__int128_t</span>&gt;(a) * b % m;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span> % m;<br>	<span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = <span class="hljs-built_in">mul</span>(a, a, m))<br>		<span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)<br>			res = <span class="hljs-built_in">mul</span>(res, a, m);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// Miller - Rabin 单素数测试</span><br>	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	<span class="hljs-type">int</span> s = __builtin_ctzll(n - <span class="hljs-number">1</span>);<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> d = (n - <span class="hljs-number">1</span>) &gt;&gt; s;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> a : check)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (a == n)<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		<span class="hljs-type">long</span> <span class="hljs-type">long</span> x = <span class="hljs-built_in">power</span>(a, d, n);<br>		<span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span> || x == n - <span class="hljs-number">1</span>)<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-type">bool</span> ok = <span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s - <span class="hljs-number">1</span>; ++i)<br>		&#123;<br>			x = <span class="hljs-built_in">mul</span>(x, x, n);<br>			<span class="hljs-keyword">if</span> (x == n - <span class="hljs-number">1</span>)<br>			&#123;<br>				ok = <span class="hljs-literal">true</span>;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (!ok)<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h3 id="4-扩展欧几里得算法-EXGCD"><a href="#4-扩展欧几里得算法-EXGCD" class="headerlink" title="4.扩展欧几里得算法(EXGCD)"></a>4.扩展欧几里得算法(EXGCD)</h3><blockquote>
<p>问题 求 $ax+by&#x3D;gcd(a,b)$ 的一组整数解<br>求出来的 $x_0$ , $y_0$ 是上面方程的一组特解<br>通解是<br>$$<br>\left{<br>\begin{array}{l}<br>x &#x3D; x_0 + ( b&#x2F;\gcd(a,b) ) \cdot k\<br>y &#x3D; y_0 - ( a&#x2F;\gcd(a,b) ) \cdot k<br>\end{array}<br>\right.<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>	&#123;<br>		x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">return</span> a;<br>	&#125;<br>	<span class="hljs-type">int</span> x1, y1, d;<span class="hljs-comment">//d是gcd(a,b)</span><br>	d = <span class="hljs-built_in">exgcd</span>(b, a % b, x1, y1);<br>	x = y1, y = x1 - a / b * y1;<br>	<span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>用exgcd求解线性同余方程 (还可以求乘法逆元)<br>把同余方程转化为不定方程 $ax ≡ b (\mod m) → ax+my&#x3D;b$<br>先求 $ax+my&#x3D;\gcd(a,m)$ 再把 $x,y$ 乘 $b&#x2F;\gcd(a,m)$ </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a, m, x, y;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;m);<br><span class="hljs-built_in">exgcd</span>(a, m, x, y);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, (x % m + m) % m);<br></code></pre></td></tr></table></figure>

<p>裴蜀定理 一定存在 $x$ $y$ 满足 $ax+by&#x3D;\gcd(a,b)$<br>裴蜀定理推广 一定存在 $x$ $y$ 满足 $ax+by&#x3D;\gcd(a,b)\cdot n$<br>裴蜀定理再推广 满足$Σ a_ix_i&#x3D;\gcd(a_1,…,a_n)$<br>更相减损术 $\gcd(a,b)&#x3D;\gcd(b,a-b)(a&gt;b)$</p>
</blockquote>
<h3 id="5-乘法逆元"><a href="#5-乘法逆元" class="headerlink" title="5.乘法逆元"></a>5.乘法逆元</h3><blockquote>
<p>如果一个线性同余方程 $ax ≡ 1 (\mod m)$，则 $x$ 被称为 $a\mod b$ 的逆元，记作 $a^{-1}$</p>
<p>线性求任意n个数的逆元</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> s[N];  <span class="hljs-comment">// n个数的前缀积</span><br>	<span class="hljs-type">int</span> sv[N]; <span class="hljs-comment">// si的逆元</span><br>	<span class="hljs-type">int</span> ans[N];<br><br>	<span class="hljs-type">int</span> n,a[N],p;<br>	s[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		s[i] = s[i - <span class="hljs-number">1</span>] * a[i] % p;<br>	sv[n] = <span class="hljs-built_in">qpow</span>(s[n], p - <span class="hljs-number">2</span>);<span class="hljs-comment">//费马小定理求乘法逆元</span><br>	<span class="hljs-comment">// 当然这里也可以用 exgcd 来求逆元,视个人喜好而定.</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; --i)<br>		sv[i - <span class="hljs-number">1</span>] = sv[i] * a[i] % p;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>		ans[i] = sv[i] * s[i - <span class="hljs-number">1</span>] % p;<br></code></pre></td></tr></table></figure>

<p>费马小定理：$ax ≡ 1(\mod m)$ 则 $x&#x3D;a^{m-2} \mod m ( m必须是质数)$</p>
<p>线性递推求乘法逆元 <code>(i==2) a[1]=1</code> <code>a[i] = 1ll*(p - p / i) * a[p % i] % p</code> m</p>
</blockquote>
<h3 id="6-欧拉函数"><a href="#6-欧拉函数" class="headerlink" title="6.欧拉函数"></a>6.欧拉函数</h3><blockquote>
<p>$1-n$ 中与 $n$ 互质的数的个数称为欧拉函数$φ(n)$</p>
<p>如果 $p$ 是质数 则 $φ(p)&#x3D;p-1$<br>如果 $p$ 是质数 则 $φ(p^k)&#x3D;(p-1)(p^{k-1})$<br>积性函数 若 $gcd(m,n)&#x3D;1$ 则 $\varphi(mn)&#x3D;\varphi(m)\varphi(n)$<br>欧兰函数仅由质因子决定，与次数无关<br>$φ(n)&#x3D;n(p_1-1)&#x2F;p_1 \cdot (p_2-1)&#x2F;p_2 \cdot…\cdot(p_s-1)&#x2F;p_s   (p_i是n的质因子)$</p>
<p>扩展性质：</p>
<ol>
<li><p>$$<br>\sum\limits_{i&#x3D;1}^n gcd(i,n)\<br>&#x3D;\sum\limits_{d \mid n}\sum\limits_{i&#x3D;1}^n d[gcd(i,n)&#x3D;d]\<br>&#x3D;\sum\limits_{d \mid n}d\sum\limits_{i&#x3D;1}^n [gcd(\frac{i}{d},\frac{n}{d})&#x3D;1]\<br>&#x3D;\sum\limits_{d \mid n}d\varphi(\frac{n}{d})\<br>[gcd(i,n)&#x3D;d]&#x3D;<br>\begin{cases}<br>1&amp;\text{gcd(i,n)&#x3D;d}\<br>0&amp;\text{gcd(i,n)≠d}<br>\end{cases}<br>$$</p>
</li>
<li><p>设 $x&#x3D;ab$，$gcd(a,b)&#x3D;d$，则$\varphi(n)&#x3D;\frac{\varphi(a)\varphi(b)d}{\varphi(d)}$</p>
</li>
<li><p>$\forall n\in N_+$ ，$ n&#x3D;\sum\limits_{d\mid n}\varphi(d)$</p>
</li>
<li><p>$n\in N_+,p为质数$,$\varphi(np)&#x3D;\begin{cases}\varphi(n)\varphi(p)&amp;p \nmid n\\varphi(n)p&amp;p \mid n\end{cases}$</p>
</li>
<li><p>对于一个数 $n(n≥2)$，所有小于等于 $n$ 且与 $n$ 互质的数的和为$\varphi(n)\frac{n}{2}$。</p>
</li>
</ol>
<p>试除法求欧拉函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> res=n;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=n;++i)<br>&#123;<br>		<span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)<br>		&#123;<br>			res=res/i*(i<span class="hljs-number">-1</span>);<br>			<span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)<br>				n/=i;<br><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)<br>		res=res/n*(n<span class="hljs-number">-1</span>);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>线性筛法求欧拉函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> p[N], vis[N], cnt;<br><span class="hljs-type">int</span> phi[N];<br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_phi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 线性筛法求欧拉函数</span><br>phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (!vis[i])<br>		&#123;<br>			p[++cnt] = i;<br>			phi[i] = i - <span class="hljs-number">1</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; i * p[j] &lt;= n; j++)<br>		&#123;<br>			<span class="hljs-type">int</span> m = i * p[j];<br>			vis[m] = <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">if</span> (i % p[j] == <span class="hljs-number">0</span>)<br>			&#123;<br>				phi[m] = p[j] * phi[i];<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>				phi[m] = (p[j] - <span class="hljs-number">1</span>) * phi[i];<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<h3 id="7-欧拉定理"><a href="#7-欧拉定理" class="headerlink" title="7.欧拉定理"></a>7.欧拉定理</h3><blockquote>
<p>与欧拉函数紧密相关的一个定理就是欧拉定理</p>
<p> 如果 $gcd(a,m)&#x3D;1$ 那么 $a^{φ(m)} ≡ 1 (\mod m)$</p>
<p>剩余类 模 $n$ 的余数相同的归为一类<br>完全剩余系 从 $n$ 个不同的剩余系中取出一个 所有余数<br>简化剩余系 有 $φ(n)$ 个模 $n$ 的余数 $r$ 与 $n$ 互质的剩余类，总共 $φ(n)$ 个数<br>$$<br>a^b\equiv<br>\begin{cases}<br>a^b&amp; b &lt; \varphi(m) (\mod m)\<br>a^{(b \mod \varphi(m))+\varphi(m)}&amp;b ≥ \varphi(m)(\mod m)\end{cases}<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> <span class="hljs-comment">// 试除法求欧拉函数</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> res = n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; ++i)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)<br>		&#123;<br>			res = res * (i - <span class="hljs-number">1</span>) / i;<br>			<span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>)<br>				n /= i;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>)<br>		res = res * (n - <span class="hljs-number">1</span>) / n;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depow</span><span class="hljs-params">(<span class="hljs-type">int</span> phi, string s)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 降幂</span><br>	<span class="hljs-type">int</span> b = <span class="hljs-number">0</span>, flag = <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; s[i]; i++)<br>	&#123;<br>		b = b * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>		<span class="hljs-keyword">if</span> (b &gt;= phi)<br>			flag = <span class="hljs-number">1</span>, b %= phi;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (flag)<br>		b += phi;<br>	<span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="8-中国剩余定理-CRT"><a href="#8-中国剩余定理-CRT" class="headerlink" title="8.中国剩余定理(CRT)"></a>8.中国剩余定理(CRT)</h3><blockquote>
<p>求解线性同余方程组<br>$$<br>\left{<br>\begin{array}{l}<br>x ≡ r_1 (\mod m_1)\<br>x ≡ r_2 (\mod m_2)\<br>x ≡ r_3 (\mod m_3)\<br>…<br>\end{array}<br>\right.<br>$$<br>其中模数 $m_1,m_2 …$为两两互质的整数 求 $x$ 的最小非负整数解<br>解法：</p>
<ol>
<li><p>计算所有模数的积 $M$</p>
</li>
<li><p>计算第 $i$ 个方程的 $c_i &#x3D; M &#x2F; m_i$</p>
</li>
<li><p>计算 $c_i$ 在模 $m_i$ 意义下的逆元 $c_i^{-1}$</p>
</li>
<li><p>$x&#x3D;Σ(1-n) r_i \cdot c_i \cdot c_i^{-1} (\mod M)$</p>
</li>
</ol>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-type">int</span> a[N], b[N], c[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>	&#123;<br>		x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">return</span> a;<br>	&#125;<br>	<span class="hljs-type">int</span> x1, y1, d;<br>	d = <span class="hljs-built_in">exgcd</span>(b, a % b, x1, y1);<br>	x = y1, y = x1 - a / b * y1;<br>	<span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n, mul = <span class="hljs-number">1</span>;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>	&#123;<br>		<span class="hljs-comment">// cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br>		cin &gt;&gt; a[i] &gt;&gt; b[i];<br>		mul *= a[i];<br>	&#125;<br><br>	<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>	&#123;<br>		c[i] = mul / a[i];<br>		<span class="hljs-type">int</span> x, y;<br>		<span class="hljs-built_in">exgcd</span>(c[i], a[i], x, y);<br>		ans = ((ans + c[i] * x * b[i]) % mul + mul) % mul;<br>	&#125;<br>	ans = (ans % mul + mul) % mul;<br>	cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="9-扩展中国剩余定理-EXCRT"><a href="#9-扩展中国剩余定理-EXCRT" class="headerlink" title="9.扩展中国剩余定理(EXCRT)"></a>9.扩展中国剩余定理(EXCRT)</h3><blockquote>
<p>前两个方程$ x ≡ r_1 (\mod m_1) ,x ≡ r_2 (\mod m_2)$<br>转化为不定方程 $x &#x3D; m_1 \cdot p + r1 &#x3D; m_2 \cdot q + r_2$<br>则$m_1 \cdot p - m_2 \cdot q &#x3D; r_2 - r_1(p对应x，q对应y)$<br>由裴蜀定理<br>当 $r_2-r_1$ 能整除 $gcd(m_1,m_2)$ 该方程有整数解 反之则没有</p>
<p>由exgcd得特解 $p &#x3D; p \frac {r_2 - r_1}  {\gcd}$ , $q &#x3D; q  \frac{r_2 - r_1} {\gcd}$</p>
<p>得到通解 $P &#x3D; p + \frac{m_2}{\gcd} k , Q &#x3D; q - \frac{m_1}{\gcd} k$</p>
<p>所以 $x &#x3D; m_1 P + r_1 &#x3D; m_1  \frac{m_2}{\gcd} k + m_1  p + r_1$</p>
<p>前两个方程等价合并为一个方程 $x ≡ r (\mod m)$</p>
<p>其中 $r &#x3D; m_1  p + r_1, m &#x3D; lcm (m_1,m_2)$</p>
<p>所以 $n$ 个同余方程只要合并 $n-1$ 次就可以求解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>	&#123;<br>		x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">return</span> a;<br>	&#125;<br>	<span class="hljs-type">int</span> d, x1, y1;<br>	d = <span class="hljs-built_in">exgcd</span>(b, a % b, x1, y1);<br>	x = y1, y = x1 - a / b * y1;<br>	<span class="hljs-keyword">return</span> d;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">EXCRT</span><span class="hljs-params">(<span class="hljs-type">int</span> m[], <span class="hljs-type">int</span> r[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> m1, m2, r1, r2, p, q;<br>	m1 = m[<span class="hljs-number">1</span>], r1 = r[<span class="hljs-number">1</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>	&#123;<br>		m2 = m[i], r2 = r[i];<br>		<span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(m1, m2, p, q);<br>		<span class="hljs-keyword">if</span> ((r2 - r1) % d)<br>		&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>		&#125;<br>		p = p * (r2 - r1) / d; <span class="hljs-comment">// 特解</span><br>		p = (p % (m2 / d) + m2 / d) % (m2 / d);<br>		r1 = m1 * p + r1;<br>		m1 = m1 * m2 / d;<br>	&#125;<br>	<span class="hljs-keyword">return</span> (r1 % m1 + m1) % m1;<br>&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<h3 id="10-其他"><a href="#10-其他" class="headerlink" title="10.其他"></a>10.其他</h3><blockquote>
<ul>
<li><p>组合数取模</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-function"><span class="hljs-type">const</span> LL <span class="hljs-title">maxn</span><span class="hljs-params">(<span class="hljs-number">1000005</span>)</span>, <span class="hljs-title">mod</span><span class="hljs-params">(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)</span></span>;<br>LL Jc[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calJc</span><span class="hljs-params">()</span> <span class="hljs-comment">// 求maxn以内的数的阶乘</span></span><br><span class="hljs-function"></span>&#123;<br>	Jc[<span class="hljs-number">0</span>] = Jc[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (LL i = <span class="hljs-number">2</span>; i &lt; maxn; i++)<br>		Jc[i] = Jc[i - <span class="hljs-number">1</span>] * i % mod;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//拓展欧几里得算法求逆元</span><br><span class="hljs-comment">void exgcd(LL a, LL b, LL &amp;x, LL &amp;y)	//拓展欧几里得算法</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">	if(!b) x = 1, y = 0;</span><br><span class="hljs-comment">	else</span><br><span class="hljs-comment">	&#123;</span><br><span class="hljs-comment">		exgcd(b, a % b, y, x);</span><br><span class="hljs-comment">    	y -= x * (a / b);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">LL niYuan(LL a, LL b)	//求a对b取模的逆元</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">	LL x, y;</span><br><span class="hljs-comment">	exgcd(a, b, x, y);</span><br><span class="hljs-comment">   return (x + b) % b;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 费马小定理求逆元</span><br><span class="hljs-function">LL <span class="hljs-title">pow</span><span class="hljs-params">(LL a, LL n, LL p)</span> <span class="hljs-comment">// 快速幂 a^n % p</span></span><br><span class="hljs-function"></span>&#123;<br>	LL ans = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">while</span> (n)<br>   &#123;<br>   	<span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>)<br>   		ans = ans * a % p;<br>   	a = a * a % p;<br>    n &gt;&gt;= <span class="hljs-number">1</span>;<br>   &#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">niYuan</span><span class="hljs-params">(LL a, LL b)</span> <span class="hljs-comment">// 费马小定理求逆元</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(a, b - <span class="hljs-number">2</span>, b);<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">C</span><span class="hljs-params">(LL a, LL b)</span> <span class="hljs-comment">// 计算C(a, b)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (a &lt; b)<br> 	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">return</span> Jc[a] * <span class="hljs-built_in">niYuan</span>(Jc[b], mod) % mod * <span class="hljs-built_in">niYuan</span>(Jc[a - b], mod) % mod;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>等比数列求和取模</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_power</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span> (n)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>)<br>			ans = ans * a % mod;<br>		a = a * a % mod;<br>		n &gt;&gt;= <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> k)</span> <span class="hljs-comment">// p底数 k指数 求(p^0 + p^1 + ... + p^k) % mod</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>	&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> + (p % mod) * (<span class="hljs-built_in">sum</span>(p, k - <span class="hljs-number">1</span>) % mod)) % mod;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-built_in">return</span> (<span class="hljs-built_in">sum</span>(p % mod, k / <span class="hljs-number">2</span>) % mod) * (<span class="hljs-number">1</span> + <span class="hljs-built_in">quick_power</span>(p, k / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)) % mod;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>$ab&#x3D;\gcd(a,b)\cdot lcm(a,b)$</p>
</li>
<li><p>斐波那契数列一个性质 $f_i\cdot f_{i+3}-f_{i+1}\cdot f_{i+2}&#x3D;(-1)^{i-1}$</p>
</li>
<li><p>伯特兰-切比雪夫定理<br>伯特兰—切比雪夫定理说明：若整数 $n＞3$ ，则至少存在一个质数 $p$ ，符合 $n＜p＜2n − 2$<br>另一个稍弱说法是：对于所有大于 $1$ 的整数 $n$ ，至少存在一个质数 $p$ ，符合 $n＜p＜2n$</p>
</li>
<li><p>皮萨诺周期：模 $m$ 意义下斐波那契数列的最小正周期被称为 皮萨诺周期<br>皮萨诺周期总是不超过 $6m$ ，且只有在满足 $m&#x3D;2 \times 5^k$  的形式时才取到等号</p>
</li>
<li><p>整除分块 $\left\lfloor \frac{n}{i}\right\rfloor$<br>性质1 分块的块数 $≤ 2  \sqrt x$  (下取整)<br>性质2 $i$ 所在块的右端点为 $\left\lfloor\cfrac{n}{\cfrac{n}{i}}\right\rfloor$  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> l = <span class="hljs-number">1</span> ; l &lt;= n; l = r + <span class="hljs-number">1</span> )<br>    r = <span class="hljs-built_in">min</span>(n / n / l , n);<br></code></pre></td></tr></table></figure>

<p>$N \bmod i &#x3D; N-\lfloor \frac{N}{i}\rfloor \cdot i$ 在 $\lfloor \frac{N}{i}\rfloor$  在每一个分块区间内可表示为等差数列。对于一个分块内 $[l,r]$ , 区间内的最大余数为 $N \bmod l $ ，即 $N-\lfloor \frac{N}{l}\rfloor \cdot l$</p>
</li>
<li><p>有理数取模<br>给出一个有理数 $c&#x3D;a&#x2F;b$ 求 $c \mod d$ 的值<br>这个值被定义为 $bx ≡ a (\mod d)$ 的解</p>
</li>
<li><p>中位数定理：如果有一个数轴，数轴上有若干个点。要在数轴上找一点，使得它到各个点的距离之和最短，<strong>中位数</strong>就是最优解。中位数有这样的性质 ：所有数与中位数的绝对差之和最小。中位数是数列中间的那个数，或者是中间的那两个数之一。</p>
</li>
</ul>
</blockquote>
<h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h2><h3 id="1-火车头"><a href="#1-火车头" class="headerlink" title="1.火车头"></a>1.火车头</h3><blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 9e18</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> inf 0x7fffffff</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159265358</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&quot;\n&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> No cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Yes cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fi first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> se second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-comment">//   #define int __int128</span><br><span class="hljs-comment">//   #define double long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lc p &lt;&lt; 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rc p &lt;&lt; 1 | 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DIN freopen(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DOUT freopen(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);</span><br><span class="hljs-comment">// 方向</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">50</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e6</span> + <span class="hljs-number">7</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>	cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>	cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>	<span class="hljs-comment">// DIN;</span><br>	<span class="hljs-comment">// DOUT;</span><br><br>	<span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>	<span class="hljs-comment">// cin &gt;&gt; T;</span><br>	<span class="hljs-keyword">while</span> (T--)<br>		<span class="hljs-built_in">solve</span>();<br>	<span class="hljs-comment">// cerr &lt;&lt; &quot;Time:&quot; &lt;&lt; 1000 * ((double)clock()) / (double)CLOCKS_PER_SEC &lt;&lt; &quot;ms\n&quot;;</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote>
<h3 id="2-int128"><a href="#2-int128" class="headerlink" title="2.int128"></a>2.int128</h3><blockquote>
<p>int128要搭配快读快写使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>	<span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>	<span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>)<br>			f = <span class="hljs-number">-1</span>;<br>		ch = <span class="hljs-built_in">getchar</span>();<br>	&#125;<br>	<span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>	&#123;<br>		x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + (ch ^ <span class="hljs-number">48</span>);<br>		ch = <span class="hljs-built_in">getchar</span>();<br>	&#125;<br>	n = x * f;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>	&#123;<br>		<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>		n *= <span class="hljs-number">-1</span>;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">9</span>)<br>		<span class="hljs-built_in">print</span>(n / <span class="hljs-number">10</span>);<br>	<span class="hljs-built_in">putchar</span>(n % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

</blockquote>
<h3 id="3-二分查找-答案"><a href="#3-二分查找-答案" class="headerlink" title="3.二分查找&#x2F;答案"></a>3.二分查找&#x2F;答案</h3><blockquote>
<p>二分查找&#x2F;答案 保证在对应的指针在有效区间(指所有满足条件的数)内 最后对应的指针所在位置就是答案</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m, q, a[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> q)</span> <span class="hljs-comment">// 查找最后一个≥q的数的下标  (二分答案 求最小化答案)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n + <span class="hljs-number">1</span>; <span class="hljs-comment">// 开区间</span><br>	<span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r)<br>	&#123; <span class="hljs-comment">// l+1=r时结束</span><br>		<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span> (a[mid] &gt;= q) <span class="hljs-comment">// 二分答案 if(check(mid))</span><br>			r = mid;	 <span class="hljs-comment">// 最小化</span><br>		<span class="hljs-keyword">else</span><br>			l = mid;<br>	&#125;<br>	<span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> q)</span> <span class="hljs-comment">// 查找最后一个≤q的数的下标 (二分答案 求最大化答案)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n + <span class="hljs-number">1</span>; <span class="hljs-comment">// 开区间</span><br>	<span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r)<br>	&#123; <span class="hljs-comment">// l+1=r时结束</span><br>		<span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span> (a[mid] &lt;= q) <span class="hljs-comment">// 二分答案 if(check(mid))</span><br>			l = mid;	 <span class="hljs-comment">// 最小化</span><br>		<span class="hljs-keyword">else</span><br>			r = mid;<br>	&#125;<br>	<span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-位运算"><a href="#4-位运算" class="headerlink" title="4.位运算"></a>4.位运算</h3><blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//时间复杂度O(3^n - 2^n)</span><br><span class="hljs-type">int</span> stg=<span class="hljs-number">2</span>^n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stg; ++i)<br>	<span class="hljs-comment">// 一种位运算的技巧，效果类似不断右移直到最低位是1再进行计算，此处是在不断枚举i的非空子集</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt; <span class="hljs-number">0</span>; j = i &amp; (j - <span class="hljs-number">1</span>))<br>		<span class="hljs-comment">//j就是i的非空子集</span><br></code></pre></td></tr></table></figure>

<ul>
<li>若 $a \bigoplus b&#x3D;c $ ，则 $ a \bigoplus c&#x3D;b$</li>
<li>$a-b≤a\bigoplus b \ (a≥b)$</li>
</ul>
</blockquote>
<h3 id="5-对拍"><a href="#5-对拍" class="headerlink" title="5.对拍"></a>5.对拍</h3><blockquote>
<ul>
<li><p>std.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;std.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br></code></pre></td></tr></table></figure>
</li>
<li><p>baoli.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;baoli.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br></code></pre></td></tr></table></figure>
</li>
<li><p>data.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">_timeb</span> T;<br>	_ftime(&amp;T);<br>	<span class="hljs-built_in">srand</span>(T.millitm);<br><br>	<span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout); <span class="hljs-comment">// 生成 使两份基本代码 将要读入的数据</span><br>	cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>	<span class="hljs-type">int</span> n = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span> + <span class="hljs-number">1</span>;<br>	n *= <span class="hljs-number">2</span>;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>	&#123;<br>		<span class="hljs-type">int</span> a = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">1000000</span> + <span class="hljs-number">1</span>;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a);<br>	&#125;<br>	cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>duipai.cpp</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
&#123;
    while (1) // 一直循环，直到找到不一样的数据
    &#123;
        system(&quot;data.exe&quot;);
        system(&quot;baoli.exe&quot;);
        system(&quot;std.exe&quot;);
        if (system(&quot;fc std.txt baoli.txt&quot;)) // 当 fc 返回 1 时，说明这时数据不一样
            break;                            // 不一样就跳出循环
    &#125;
    system(&quot;pause&quot;);
                                                        
    return 0;
&#125;
</code></pre>
</li>
</ul>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/XCPC/" class="print-no-link">#XCPC</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>template</div>
      <div>http://example.com/2025/02/07/template/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年2月7日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/02/07/post/" title="post">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">post</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/07/hello-world/" title="Hello World">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
